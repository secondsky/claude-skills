{
  "name": "claude-skills",
  "owner": {
    "name": "Claude Skills Maintainers",
    "email": "maintainers@example.com",
    "url": "https://github.com/secondsky/claude-skills"
  },
  "metadata": {
    "description": "Production-tested skills for Claude Code - Cloudflare, AI, React, Tailwind v4, and modern web development",
    "version": "3.0.0",
    "homepage": "https://github.com/secondsky/claude-skills"
  },
  "plugins": [
    {
      "name": "access-control-rbac",
      "source": "./skills/access-control-rbac",
      "description": "Implements role-based access control (RBAC), permissions management, and authorization policies for secure multi-tenant applications. Use when building admin dashboards, enterprise access management, API authorization, or fine-grained data access controls. ",
      "keywords": ["access-control-rbac","access","control","rbac","security","vulnerability","protection","csrf","xss","api","authorization"],
      "category": "security"
    }
,
    {
      "name": "aceternity-ui",
      "source": "./skills/aceternity-ui",
      "description": "Build modern, animated React UI components with Aceternity UI - a premium component library featuring 100+ production-ready components including backgrounds, 3D effects, cards, animations, and interactive elements. Use when building Next.js applications with Tailwind CSS that need visually stunning hero sections, animated backgrounds, interactive cards, parallax effects, animated text, smooth transitions, or modern UI elements. Ideal for landing pages, portfolios, SaaS applications, and marketing websites requiring professional animations and visual effects. Includes shadcn CLI integration for easy component installation. ",
      "keywords": ["aceternity-ui","aceternity","frontend","components","react","typescript","cli","css","saas","production","integration"],
      "category": "frontend"
    }
,
    {
      "name": "ai-elements-chatbot",
      "source": "./skills/ai-elements-chatbot",
      "description": "This skill provides production-ready AI chat UI components built on shadcn/ui for conversational AI interfaces. Use when building ChatGPT-style chat interfaces with streaming responses, tool/function call displays, reasoning visualization, or source citations. Provides 30+ components including Message, Conversation, Response, CodeBlock, Reasoning, Tool, Actions, Sources optimized for Vercel AI SDK v5. Prevents common setup errors with Next.js App Router, Tailwind v4, shadcn/ui integration, AI SDK v5 migration, component composition patterns, voice input browser compatibility, responsive design issues, and streaming optimization. Keywords: ai-elements, vercel-ai-sdk, shadcn, chatbot, conversational-ai, streaming-ui, chat-interface, ai-chat, message-components, conversation-ui, tool-calling, reasoning-display, source-citations, markdown-streaming, function-calling, ai-responses, prompt-input, code-highlighting, web-preview, branch-navigation, thinking-display, perplexity-style, claude-artifacts ",
      "keywords": ["ai-elements-chatbot","elements","chatbot","machine-learning","llm","artificial-intelligence","sdk","chatgpt","codeblock","production","optimization","integration","migration","streaming"],
      "category": "ai"
    }
,
    {
      "name": "ai-sdk-core",
      "source": "./skills/ai-sdk-core",
      "description": "Backend AI functionality with Vercel AI SDK v5 - text generation, structured output with Zod, tool calling, and agents. Multi-provider support for OpenAI, Anthropic, Google, and Cloudflare Workers AI. Use when: implementing server-side AI features, generating text/chat completions, creating structured AI outputs with Zod schemas, building AI agents with tools, streaming AI responses, integrating OpenAI/Anthropic/Google/Cloudflare providers, or encountering AI SDK errors like AI_APICallError, AI_NoObjectGeneratedError, streaming failures, or worker startup limits. Keywords: ai sdk core, vercel ai sdk, generateText, streamText, generateObject, streamObject, ai sdk node, ai sdk server, zod ai schema, ai tools calling, ai agent class, openai sdk, anthropic sdk, google gemini sdk, workers-ai-provider, ai streaming backend, multi-provider ai, ai sdk errors, AI_APICallError, AI_NoObjectGeneratedError, streamText fails, worker startup limit ai ",
      "keywords": ["ai-sdk-core","sdk","core","machine-learning","llm","artificial-intelligence","openai","streaming"],
      "category": "ai"
    }
,
    {
      "name": "ai-sdk-ui",
      "source": "./skills/ai-sdk-ui",
      "description": "Frontend React hooks for AI-powered chat interfaces, completions, and streaming UIs with Vercel AI SDK v5. Includes useChat, useCompletion, and useObject hooks for building interactive AI applications. Use when: building React chat interfaces, implementing AI completions in UI, streaming AI responses to frontend, handling chat message state, building Next.js AI apps, managing file attachments with AI, or encountering errors like \"useChat failed to parse stream\", \"useChat no response\", unclosed streams, or streaming issues. Keywords: ai sdk ui, useChat hook, useCompletion hook, useObject hook, react ai chat, ai chat interface, streaming ai ui, nextjs ai chat, vercel ai ui, react streaming, ai sdk react, chat message state, ai file attachments, message persistence, useChat error, streaming failed ui, parse stream error, useChat no response, react ai hooks, nextjs app router ai, nextjs pages router ai ",
      "keywords": ["ai-sdk-ui","sdk","machine-learning","llm","artificial-intelligence","streaming"],
      "category": "ai"
    }
,
    {
      "name": "api-authentication",
      "source": "./skills/api-authentication",
      "description": "Implements secure API authentication using JWT, OAuth 2.0, and API keys with proper token management and security headers. Use when building authentication systems, integrating third-party providers, or securing service-to-service communication. ",
      "keywords": ["api-authentication","api","authentication","rest","graphql","endpoints","http","jwt"],
      "category": "api"
    }
,
    {
      "name": "api-changelog-versioning",
      "source": "./skills/api-changelog-versioning",
      "description": "Creates comprehensive API changelogs documenting breaking changes, deprecations, and migration strategies for API consumers. Use when managing API versions, communicating breaking changes, or creating upgrade guides. ",
      "keywords": ["api-changelog-versioning","api","changelog","versioning","rest","graphql","endpoints","http","migration"],
      "category": "api"
    }
,
    {
      "name": "api-contract-testing",
      "source": "./skills/api-contract-testing",
      "description": "Verifies API contracts between services using consumer-driven contracts, schema validation, and tools like Pact. Use when testing microservices communication, preventing breaking changes, or validating OpenAPI specifications. ",
      "keywords": ["api-contract-testing","api","contract","testing","rest","graphql","endpoints","http","openapi","validation"],
      "category": "api"
    }
,
    {
      "name": "api-design-principles",
      "source": "./skills/api-design-principles",
      "description": "Master REST and GraphQL API design principles to build intuitive, scalable, and maintainable APIs that delight developers. Use when designing new APIs, reviewing API specifications, or establishing API design standards. ",
      "keywords": ["api-design-principles","api","design","principles","rest","graphql","endpoints","http","scalable","maintainable"],
      "category": "api"
    }
,
    {
      "name": "api-error-handling",
      "source": "./skills/api-error-handling",
      "description": "Implements standardized API error responses with proper status codes, logging, and user-friendly messages. Use when building production APIs, implementing error recovery patterns, or integrating error monitoring services. ",
      "keywords": ["api-error-handling","api","error","handling","rest","graphql","endpoints","http","production"],
      "category": "api"
    }
,
    {
      "name": "api-filtering-sorting",
      "source": "./skills/api-filtering-sorting",
      "description": "Builds flexible API filtering and sorting systems with query parameter parsing, validation, and security. Use when implementing search endpoints, building data grids, or creating dynamic query APIs. ",
      "keywords": ["api-filtering-sorting","api","filtering","sorting","rest","graphql","endpoints","http","validation"],
      "category": "api"
    }
,
    {
      "name": "api-gateway-configuration",
      "source": "./skills/api-gateway-configuration",
      "description": "Configures API gateways for routing, authentication, rate limiting, and request transformation in microservice architectures. Use when setting up Kong, Nginx, AWS API Gateway, or Traefik for centralized API management. ",
      "keywords": ["api-gateway-configuration","api","gateway","configuration","rest","graphql","endpoints","http","aws","authentication"],
      "category": "api"
    }
,
    {
      "name": "api-pagination",
      "source": "./skills/api-pagination",
      "description": "Implements efficient API pagination using offset, cursor, and keyset strategies for large datasets. Use when building paginated endpoints, implementing infinite scroll, or optimizing database queries for collections. ",
      "keywords": ["api-pagination","api","pagination","rest","graphql","endpoints","http"],
      "category": "api"
    }
,
    {
      "name": "api-rate-limiting",
      "source": "./skills/api-rate-limiting",
      "description": "Implements API rate limiting using token bucket, sliding window, and Redis-based algorithms to protect against abuse. Use when securing public APIs, implementing tiered access, or preventing denial-of-service attacks. ",
      "keywords": ["api-rate-limiting","api","rate","limiting","rest","graphql","endpoints","http"],
      "category": "api"
    }
,
    {
      "name": "api-reference-documentation",
      "source": "./skills/api-reference-documentation",
      "description": "Creates professional API documentation using OpenAPI specifications with endpoints, authentication, and interactive examples. Use when documenting REST APIs, creating SDK references, or building developer portals. ",
      "keywords": ["api-reference-documentation","api","reference","documentation","rest","graphql","endpoints","http","sdk","openapi","authentication"],
      "category": "api"
    }
,
    {
      "name": "api-response-optimization",
      "source": "./skills/api-response-optimization",
      "description": "Optimizes API performance through payload reduction, caching strategies, and compression techniques. Use when improving API response times, reducing bandwidth usage, or implementing efficient caching. ",
      "keywords": ["api-response-optimization","api","response","optimization","rest","graphql","endpoints","http","caching"],
      "category": "api"
    }
,
    {
      "name": "api-security-hardening",
      "source": "./skills/api-security-hardening",
      "description": "Hardens REST APIs against common vulnerabilities through authentication, rate limiting, input validation, and security headers. Use when securing production APIs, conducting security audits, or implementing defense-in-depth strategies. ",
      "keywords": ["api-security-hardening","api","security","hardening","rest","graphql","endpoints","http","production","authentication","validation"],
      "category": "api"
    }
,
    {
      "name": "api-testing",
      "source": "./skills/api-testing",
      "description": "HTTP API testing for TypeScript (Supertest) and Python (httpx, pytest). Test REST APIs, GraphQL, request/response validation, authentication, and error handling. ",
      "keywords": ["api-testing","api","testing","rest","graphql","endpoints","http","typescript","authentication","validation"],
      "category": "api"
    }
,
    {
      "name": "api-versioning-strategy",
      "source": "./skills/api-versioning-strategy",
      "description": "Implements API versioning using URL paths, headers, or query parameters with backward compatibility and deprecation strategies. Use when managing multiple API versions, planning breaking changes, or designing migration paths. ",
      "keywords": ["api-versioning-strategy","api","versioning","strategy","rest","graphql","endpoints","http","url","migration"],
      "category": "api"
    }
,
    {
      "name": "app-store-deployment",
      "source": "./skills/app-store-deployment",
      "description": "Publishes mobile applications to iOS App Store and Google Play with code signing, versioning, and CI/CD automation. Use when preparing app releases, configuring signing certificates, or setting up automated deployment pipelines. ",
      "keywords": ["app-store-deployment","app","store","deployment","mobile","ios","android","native"],
      "category": "mobile"
    }
,
    {
      "name": "architecture-patterns",
      "source": "./skills/architecture-patterns",
      "description": "Implement proven backend architecture patterns including Clean Architecture, Hexagonal Architecture, and Domain-Driven Design. Use when architecting complex backend systems or refactoring existing applications for better maintainability. ",
      "keywords": ["architecture-patterns","architecture","patterns","microservices","design","refactoring"],
      "category": "architecture"
    }
,
    {
      "name": "auto-animate",
      "source": "./skills/auto-animate",
      "description": "Production-tested setup for AutoAnimate (@formkit/auto-animate) - a zero-config, drop-in animation library that automatically adds smooth transitions when DOM elements are added, removed, or moved. This skill should be used when building UIs that need simple, automatic animations for lists, accordions, toasts, or form validation messages without the complexity of full animation libraries. Use when: Adding smooth animations to dynamic lists, building filter/sort interfaces, creating accordion components, implementing toast notifications, animating form validation messages, needing simple transitions without animation code, working with Vite + React + Tailwind, deploying to Cloudflare Workers Static Assets, or encountering SSR errors with animation libraries. Keywords: auto-animate, @formkit/auto-animate, formkit, zero-config animation, automatic animations, drop-in animation, list animations, accordion animation, toast animation, form validation animation, lightweight animation, 2kb animation, prefers-reduced-motion, accessible animations, vite react animation, cloudflare workers animation, ssr safe animation ",
      "keywords": ["auto-animate","auto","animate","frontend","components","react","typescript","dom","ssr","autoanimate","production","validation"],
      "category": "frontend"
    }
,
    {
      "name": "base-ui-react",
      "source": "./skills/base-ui-react",
      "description": "Production-tested setup for Base UI (@base-ui-components/react) - MUI's unstyled component library that provides accessible, customizable React components using render props pattern. This skill should be used when building accessible UIs with full styling control, migrating from Radix UI, or needing components with Floating UI integration for smart positioning. Use when: Setting up Base UI in Vite + React projects, migrating from Radix UI to Base UI, implementing accessible components (Dialog, Select, Popover, Tooltip, NumberField, Accordion), encountering positioning issues with popups, needing render prop API instead of asChild pattern, building with Tailwind v4 + shadcn/ui, or deploying to Cloudflare Workers. ⚠️ BETA STATUS: Base UI is v1.0.0-beta.4. Stable v1.0 expected Q4 2025. This skill provides workarounds for known beta issues and guidance on API stability. Keywords: base-ui, @base-ui-components/react, mui base ui, unstyled components, accessible components, render props, radix alternative, radix migration, floating-ui, positioner pattern, headless ui, accessible dialog, accessible select, accessible popover, accessible tooltip, accessible accordion, number field, react components, tailwind components, vite react, cloudflare workers ui, beta components, component library ",
      "keywords": ["base-ui-react","base","react","frontend","components","typescript","api","beta","mui","status","numberfield","production","integration","migration"],
      "category": "frontend"
    }
,
    {
      "name": "better-auth",
      "source": "./skills/better-auth",
      "description": "Production-ready authentication framework for TypeScript with Cloudflare D1 support via Drizzle ORM or Kysely. Use this skill when building auth systems as a self-hosted alternative to Clerk or Auth.js, particularly for Cloudflare Workers projects. CRITICAL: better-auth requires Drizzle ORM or Kysely as database adapters - there is NO direct D1 adapter. Supports social providers (Google, GitHub, Microsoft, Apple), email/password, magic links, 2FA, passkeys, organizations, and RBAC. Prevents 12+ common authentication errors including D1 adapter misconfiguration, schema generation issues, session serialization, CORS, OAuth flows, and JWT token handling. Keywords: better-auth, authentication, cloudflare d1 auth, drizzle orm auth, kysely auth, self-hosted auth, typescript auth, clerk alternative, auth.js alternative, social login, oauth providers, session management, jwt tokens, 2fa, two-factor, passkeys, webauthn, multi-tenant auth, organizations, teams, rbac, role-based access, google auth, github auth, microsoft auth, apple auth, magic links, email password, better-auth setup, drizzle d1, kysely d1, session serialization error, cors auth, d1 adapter ",
      "keywords": ["better-auth","better","auth","authentication","authorization","login","security","session","cors","critical","jwt","orm","rbac","github","typescript","production"],
      "category": "auth"
    }
,
    {
      "name": "better-chatbot",
      "source": "./skills/better-chatbot",
      "description": "This skill provides project-specific coding conventions, architectural principles, repository structure standards, testing patterns, and contribution guidelines for the better-chatbot project (https://github.com/cgoinglove/better-chatbot). Use this skill when contributing to or working with better-chatbot to understand the design philosophy and ensure code follows established patterns. Includes: API architecture deep-dive, three-tier tool system (MCP/Workflow/Default), component design patterns, database repository patterns, architectural principles (progressive enhancement, defensive programming, streaming-first), practical templates for adding features (tools, routes, repositories). Use when: working in better-chatbot repository, contributing features/fixes, understanding architectural decisions, following server action validators, implementing tools/workflows, setting up Playwright tests, adding API routes, designing database queries, building UI components, handling multi-AI provider integration Keywords: better-chatbot, chatbot contribution, better-chatbot standards, chatbot development, AI chatbot patterns, API architecture, three-tier tool system, repository pattern, progressive enhancement, defensive programming, streaming-first, compound component pattern, Next.js chatbot, Vercel AI SDK chatbot, MCP tools, workflow builder, server action validators, tool abstraction, DAG workflows, shared business logic, safe() wrapper, tool lifecycle ",
      "keywords": ["better-chatbot","better","chatbot","development","tooling","workflow","api","dag","mcp","sdk","integration","streaming"],
      "category": "tooling"
    }
,
    {
      "name": "better-chatbot-patterns",
      "source": "./skills/better-chatbot-patterns",
      "description": "This skill provides reusable implementation patterns extracted from the better-chatbot project for custom AI chatbot deployments. Use this skill when building AI chatbots with server action validators, tool abstraction systems, workflow execution, or multi-AI provider integration in your own projects (not contributing to better-chatbot itself). Use when: building AI chatbot features, implementing server action validators, creating tool abstraction layers, setting up multi-AI provider support, building workflow execution systems, adapting better-chatbot patterns to custom projects Keywords: AI chatbot patterns, server action validators, tool abstraction, multi-AI providers, workflow execution, MCP integration, validated actions, tool type checking, Vercel AI SDK patterns, chatbot architecture ",
      "keywords": ["better-chatbot-patterns","better","chatbot","patterns","development","tooling","workflow","mcp","sdk","integration","implementation","deployment"],
      "category": "tooling"
    }
,
    {
      "name": "chrome-devtools",
      "source": "./skills/chrome-devtools",
      "description": "Browser automation, debugging, and performance analysis using Puppeteer CLI scripts. Use for automating browsers, taking screenshots, analyzing performance, monitoring network traffic, web scraping, form automation, and JavaScript debugging. ",
      "keywords": ["chrome-devtools","chrome","devtools","development","tooling","workflow","cli","javascript"],
      "category": "tooling"
    }
,
    {
      "name": "claude-agent-sdk",
      "source": "./skills/claude-agent-sdk",
      "description": "This skill provides comprehensive knowledge for working with the Anthropic Claude Agent SDK. It should be used when building autonomous AI agents, creating multi-step reasoning workflows, orchestrating specialized subagents, integrating custom tools and MCP servers, or implementing production-ready agentic systems with Claude Code's capabilities. Use when building coding agents, SRE systems, security auditors, incident responders, code review bots, or any autonomous system that requires programmatic interaction with Claude Code CLI, persistent sessions, tool orchestration, and fine-grained permission control. Keywords: claude agent sdk, @anthropic-ai/claude-agent-sdk, query(), createSdkMcpServer, AgentDefinition, tool(), claude subagents, mcp servers, autonomous agents, agentic loops, session management, permissionMode, canUseTool, multi-agent orchestration, settingSources, CLI not found, context length exceeded ",
      "keywords": ["claude-agent-sdk","claude","agent","sdk","machine-learning","llm","artificial-intelligence","cli","mcp","sre","agentdefinition","production"],
      "category": "ai"
    }
,
    {
      "name": "claude-api",
      "source": "./skills/claude-api",
      "description": "This skill provides comprehensive knowledge for working with the Anthropic Messages API (Claude API). It should be used when integrating Claude models into applications, implementing streaming responses, enabling prompt caching for cost savings, adding tool use (function calling), processing images with vision capabilities, or using extended thinking mode. Use when building chatbots, AI assistants, content generation tools, or any application requiring Claude's language understanding. Covers both server-side implementations (Node.js, Cloudflare Workers, Next.js) and direct API access. Keywords: claude api, anthropic api, messages api, @anthropic-ai/sdk, claude streaming, prompt caching, tool use, vision, extended thinking, claude 3.5 sonnet, claude 3.7 sonnet, claude sonnet 4, function calling, SSE, rate limits, 429 errors ",
      "keywords": ["claude-api","claude","api","machine-learning","llm","artificial-intelligence","sse","implementation","caching","streaming"],
      "category": "ai"
    }
,
    {
      "name": "claude-code-bash-patterns",
      "source": "./skills/claude-code-bash-patterns",
      "description": "Deploy to production ",
      "keywords": ["claude-code-bash-patterns","claude","code","bash","patterns","development","tooling","workflow","production"],
      "category": "tooling"
    }
,
    {
      "name": "claude-hook-writer",
      "source": "./skills/claude-hook-writer",
      "description": "Expert guidance for writing secure, reliable, and performant Claude Code hooks - validates design decisions, enforces best practices, and prevents common pitfalls. Use when creating, reviewing, or debugging Claude Code hooks. ",
      "keywords": ["claude-hook-writer","claude","hook","writer","development","tooling","workflow"],
      "category": "tooling"
    }
,
    {
      "name": "clerk-auth",
      "source": "./skills/clerk-auth",
      "description": "This skill provides comprehensive knowledge for integrating Clerk authentication in React, Next.js, and Cloudflare Workers applications. It should be used when setting up user authentication, implementing protected routes, verifying JWT tokens, creating custom JWT templates with user metadata and organization claims, configuring Clerk middleware, integrating with shadcn/ui components, testing authentication flows, or troubleshooting Clerk authentication errors. Use when: adding Clerk to React/Vite projects, setting up Clerk in Next.js App Router, implementing Clerk authentication in Cloudflare Workers, configuring clerkMiddleware for route protection, creating custom JWT templates with shortcodes (user.id, user.email, user.public_metadata.role), accessing session claims for RBAC, integrating with Supabase/Grafbase, verifying tokens with @clerk/backend, integrating Clerk with Hono, using Clerk shadcn/ui components, writing E2E tests with Playwright, generating test session tokens, using test email addresses and phone numbers, or encountering authentication errors. Prevents 11 documented issues: missing secret key errors, API key migration failures, JWKS cache race conditions, CSRF vulnerabilities from missing authorizedParties, import path errors after Core 2 upgrade, JWT size limit issues, deprecated API version warnings, ClerkProvider JSX component errors, async auth() helper confusion, environment variable misconfiguration, and Vite dev mode 431 header errors. Keywords: clerk, clerk auth, clerk authentication, @clerk/nextjs, @clerk/backend, @clerk/clerk-react, clerkMiddleware, createRouteMatcher, verifyToken, useUser, useAuth, useClerk, JWT template, JWT claims, JWT shortcodes, custom JWT, session claims, getToken template, user.public_metadata, org_id, org_slug, org_role, CustomJwtSessionClaims, sessionClaims metadata, clerk webhook, clerk secret key, clerk publishable key, protected routes, Cloudflare Workers auth, Next.js auth, shadcn/ui auth, @hono/clerk-auth, \"Missing Clerk Secret Key\", \"cannot be used as a JSX component\", JWKS error, authorizedParties, clerk middleware, ClerkProvider, UserButton, SignIn, SignUp, clerk testing, test emails, test phone numbers, +clerk_test, 424242 OTP, session token, testing token, @clerk/testing, playwright testing, E2E testing, clerk test mode, bot detection, generate session token, test users ",
      "keywords": ["clerk-auth","clerk","auth","authentication","authorization","login","security","session","api","csrf","e2e","jsx","jwks","jwt","otp","rbac","clerkprovider","customjwtsessionclaims","signin","signup","userbutton","migration","async"],
      "category": "auth"
    }
,
    {
      "name": "cloudflare-agents",
      "source": "./skills/cloudflare-agents",
      "description": "Build AI agents on Cloudflare Workers with MCP integration, tool use, and LLM providers. ",
      "keywords": ["cloudflare-agents","cloudflare","agents","workers","edge","serverless","wrangler","llm","mcp","integration"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-browser-rendering",
      "source": "./skills/cloudflare-browser-rendering",
      "description": "Complete knowledge domain for Cloudflare Browser Rendering - Headless Chrome automation with Puppeteer and Playwright on Cloudflare Workers for screenshots, PDFs, web scraping, and browser automation workflows. Use when: taking screenshots, generating PDFs from HTML or URLs, web scraping content, crawling websites, browser automation tasks, testing web applications, managing browser sessions, performing batch browser operations, integrating with AI for content extraction, or encountering browser rendering errors, XPath selector errors, browser timeout issues, concurrency limits, memory exceeded errors, or \"Cannot read properties of undefined (reading 'fetch')\" errors. Keywords: browser rendering cloudflare, @cloudflare/puppeteer, @cloudflare/playwright, puppeteer workers, playwright workers, screenshot cloudflare, pdf generation workers, web scraping cloudflare, headless chrome workers, browser automation, puppeteer.launch, playwright.chromium.launch, browser binding, session management, puppeteer.sessions, puppeteer.connect, browser.close, browser.disconnect, XPath not supported, browser timeout, concurrency limit, keep_alive, page.screenshot, page.pdf, page.goto, page.evaluate, incognito context, session reuse, batch scraping, crawling websites ",
      "keywords": ["cloudflare-browser-rendering","cloudflare","browser","rendering","workers","edge","serverless","wrangler","html"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-cron-triggers",
      "source": "./skills/cloudflare-cron-triggers",
      "description": "Complete knowledge domain for Cloudflare Cron Triggers - scheduled execution of Workers using cron expressions for periodic tasks, maintenance jobs, and automated workflows. Use when: scheduling Workers to run periodically, adding cron triggers to Workers, configuring scheduled tasks, testing cron handlers, combining crons with Workflows, enabling Green Compute, handling multiple schedules, or encountering \"scheduled handler not found\", \"cron expression invalid\", \"changes not propagating\", \"handler does not export\", \"timezone issues\" errors. Keywords: cloudflare cron, cron triggers, scheduled workers, scheduled handler, periodic tasks, background jobs, scheduled tasks, cron expression, wrangler crons, scheduled event, green compute, workflow triggers, maintenance tasks, scheduled() handler, ScheduledController, UTC timezone ",
      "keywords": ["cloudflare-cron-triggers","cloudflare","cron","triggers","workers","edge","serverless","wrangler","utc","scheduledcontroller"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-d1",
      "source": "./skills/cloudflare-d1",
      "description": "Complete knowledge domain for Cloudflare D1 - serverless SQLite database on Cloudflare's edge network. Use when: creating D1 databases, writing SQL migrations, configuring D1 bindings, querying D1 from Workers, handling SQLite data, building relational data models, or encountering \"D1_ERROR\", \"statement too long\", \"too many requests queued\", migration failures, or query performance issues. Keywords: d1, d1 database, cloudflare d1, wrangler d1, d1 migrations, d1 bindings, sqlite workers, serverless database, edge database, d1 queries, sql cloudflare, prepared statements, batch queries, d1 api, wrangler migrations, D1_ERROR, D1_EXEC_ERROR, statement too long, database bindings, sqlite cloudflare, sql workers api, d1 indexes, query optimization, d1 schema, read replication, read replica, withSession, Sessions API, global replication, database replication, served_by_region, bookmarks, sequential consistency ",
      "keywords": ["cloudflare-d1","cloudflare","workers","edge","serverless","wrangler","api","sql","optimization","migration"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-durable-objects",
      "source": "./skills/cloudflare-durable-objects",
      "description": "Comprehensive guide for Cloudflare Durable Objects - globally unique, stateful objects for coordination, real-time communication, and persistent state management. Use when: building real-time applications, creating WebSocket servers with hibernation, implementing chat rooms or multiplayer games, coordinating between multiple clients, managing per-user or per-room state, implementing rate limiting or session management, scheduling tasks with alarms, building queues or workflows, or encountering \"do class export\", \"new_sqlite_classes\", \"migrations required\", \"websocket hibernation\", \"alarm api error\", or \"global uniqueness\" errors. Prevents 15+ documented issues: class not exported, missing migrations, wrong migration type, constructor overhead blocking hibernation, setTimeout breaking hibernation, in-memory state lost on hibernation, outgoing WebSocket not hibernating, global uniqueness confusion, partial deleteAll on KV backend, binding name mismatches, state size limits exceeded, non-atomic migrations, location hints misunderstood, alarm retry failures, and fetch calls blocking hibernation. Keywords: durable objects, cloudflare do, DurableObject class, do bindings, websocket hibernation, do state api, ctx.storage.sql, ctx.acceptWebSocket, webSocketMessage, alarm() handler, storage.setAlarm, idFromName, newUniqueId, getByName, DurableObjectStub, serializeAttachment, real-time cloudflare, multiplayer cloudflare, chat room workers, coordination cloudflare, stateful workers, new_sqlite_classes, do migrations, location hints, RPC methods, blockConcurrencyWhile, \"do class export\", \"new_sqlite_classes\", \"migrations required\", \"websocket hibernation\", \"alarm api error\", \"global uniqueness\", \"binding not found\" ",
      "keywords": ["cloudflare-durable-objects","cloudflare","durable","objects","workers","edge","serverless","wrangler","rpc","durableobject","durableobjectstub","websocket","migration","real-time"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-email-routing",
      "source": "./skills/cloudflare-email-routing",
      "description": "Complete guide for Cloudflare Email Routing covering both Email Workers (receiving emails) and Send Email bindings (sending emails from Workers). Use when: setting up email routing, creating email workers, processing incoming emails, sending emails from Workers, implementing email allowlists/blocklists, forwarding emails with custom logic, replying to emails automatically, parsing email content, configuring MX records for email, troubleshooting email delivery issues, or encountering email worker errors. Prevents 8 documented issues: \"Email Trigger not available\" errors, destination address verification bugs, Gmail rate limiting, SPF permerror issues, worker call failures, test event loading issues, activity log discrepancies, and limited debugging on free plans. Keywords: Cloudflare Email Routing, Email Workers, send email, receive email, email forwarding, email allowlist, email blocklist, postal-mime, mimetext, cloudflare:email, EmailMessage, ForwardableEmailMessage, EmailEvent, MX records, SPF, DKIM, email worker binding, send_email binding, wrangler email, email handler, email routing worker, \"Email Trigger not available\", \"failed to call worker\", email delivery failed, email not forwarding, destination address not verified ",
      "keywords": ["cloudflare-email-routing","cloudflare","email","routing","workers","edge","serverless","wrangler","dkim","spf","emailevent","emailmessage","forwardableemailmessage"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-full-stack-integration",
      "source": "./skills/cloudflare-full-stack-integration",
      "description": "Production-tested integration patterns for connecting React frontends to Cloudflare Worker backends with Hono, Clerk authentication, and D1 databases. Prevents common frontend-backend connection issues, CORS errors, auth token failures, and race conditions. Use when: connecting frontend to backend, implementing auth flow, setting up API calls, troubleshooting CORS, fixing race conditions, auth tokens not passing, frontend-backend connection errors, 401 errors, integrating Clerk with Workers, setting up full-stack Cloudflare app, vite cloudflare plugin setup. Prevents: CORS errors, 401 Unauthorized, auth token mismatches, race conditions with auth loading, environment variable confusion, frontend calling wrong endpoints, JWT verification errors, D1 connection issues. Keywords: frontend backend integration, Cloudflare Workers, Hono, Clerk auth, JWT verification, CORS, React API client, race conditions, auth loading, connection issues, full-stack integration, vite plugin, @cloudflare/vite-plugin, D1 database, environment variables, token attachment, session management, protected routes, API middleware ",
      "keywords": ["cloudflare-full-stack-integration","cloudflare","full","stack","integration","workers","edge","serverless","wrangler","api","cors","jwt","production","authentication"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-full-stack-scaffold",
      "source": "./skills/cloudflare-full-stack-scaffold",
      "description": "Production-ready starter project for React + Cloudflare Workers + Hono with core services (D1, KV, R2, Workers AI) and optional advanced features (Clerk Auth, AI Chat, Queues, Vectorize). Complete with planning docs, session handoff protocol, and enable scripts for opt-in features. Use when: starting new full-stack project, creating Cloudflare app, scaffolding web app, AI-powered application, chat interface, RAG application, need complete starter, avoid setup time, production-ready template, full-stack boilerplate, React Cloudflare starter. Prevents: service configuration errors, binding setup mistakes, frontend-backend connection issues, CORS errors, auth integration problems, AI SDK setup confusion, missing planning docs, incomplete project structure, hours of initial setup. Keywords: cloudflare scaffold, full-stack starter, react cloudflare, hono template, production boilerplate, AI SDK integration, workers AI, complete starter project, D1 KV R2 setup, web app template, chat application scaffold, RAG starter, planning docs included, session handoff, tailwind v4 shadcn, typescript starter, vite cloudflare plugin, all services configured ",
      "keywords": ["cloudflare-full-stack-scaffold","cloudflare","full","stack","scaffold","workers","edge","serverless","wrangler","cors","rag","sdk","production","integration","configuration"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-hyperdrive",
      "source": "./skills/cloudflare-hyperdrive",
      "description": "Complete knowledge domain for Cloudflare Hyperdrive - connecting Cloudflare Workers to existing PostgreSQL and MySQL databases with global connection pooling, query caching, and reduced latency. Use when: connecting Workers to existing databases, migrating PostgreSQL/MySQL to Cloudflare, setting up connection pooling, configuring Hyperdrive bindings, using node-postgres/postgres.js/mysql2 drivers, integrating Drizzle ORM or Prisma ORM, or encountering \"Failed to acquire a connection from the pool\", \"TLS not supported by the database\", \"connection refused\", \"nodejs_compat missing\", \"Code generation from strings disallowed\", or Hyperdrive configuration errors. Keywords: hyperdrive, cloudflare hyperdrive, workers hyperdrive, postgres workers, mysql workers, connection pooling, query caching, node-postgres, pg, postgres.js, mysql2, drizzle hyperdrive, prisma hyperdrive, workers rds, workers aurora, workers neon, workers supabase, database acceleration, hybrid architecture, cloudflare tunnel database, wrangler hyperdrive, hyperdrive bindings, local development hyperdrive ",
      "keywords": ["cloudflare-hyperdrive","cloudflare","hyperdrive","workers","edge","serverless","wrangler","orm","tls","mysql","postgresql","configuration","caching"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-images",
      "source": "./skills/cloudflare-images",
      "description": "This skill provides comprehensive knowledge for Cloudflare Images, covering both the Images API (upload/storage) and Image Transformations (optimize any image). It should be used when uploading images to Cloudflare, resizing images, optimizing image delivery, implementing direct creator uploads, creating image variants, generating signed URLs for private images, transforming images via Workers, or encountering image upload/transformation errors. Use when: setting up Cloudflare Images storage, implementing user-uploaded images, creating responsive images, optimizing image formats (WebP/AVIF), resizing images via URL or Workers, debugging CORS errors with direct uploads, handling image transformation errors (9401-9413), implementing signed URLs, managing image variants, or building image CDNs. Keywords: cloudflare images, image upload cloudflare, imagedelivery.net, cloudflare image transformations, /cdn-cgi/image/, direct creator upload, image variants, cf.image workers, signed urls images, flexible variants, webp avif conversion, responsive images cloudflare, error 5408, error 9401, error 9403, CORS direct upload, multipart/form-data, image optimization cloudflare ",
      "keywords": ["cloudflare-images","cloudflare","images","workers","edge","serverless","wrangler","api","avif","cors","url","webp","optimization"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-kv",
      "source": "./skills/cloudflare-kv",
      "description": "Complete knowledge domain for Cloudflare Workers KV - global, low-latency key-value storage on Cloudflare's edge network. Use when: creating KV namespaces, storing configuration data, caching API responses, managing user preferences, implementing TTL expiration, handling KV metadata, or encountering \"KV_ERROR\", \"429 too many requests\", \"kv rate limit\", cacheTtl errors, or eventual consistency issues. Keywords: kv storage, cloudflare kv, workers kv, kv namespace, kv bindings, kv cache, kv ttl, kv metadata, kv list, kv pagination, cache optimization, edge caching, KV_ERROR, 429 too many requests, kv rate limit, eventually consistent, wrangler kv, kv operations, key value storage ",
      "keywords": ["cloudflare-kv","cloudflare","workers","edge","serverless","wrangler","api","ttl","optimization","configuration","caching"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-manager",
      "source": "./skills/cloudflare-manager",
      "description": "Comprehensive Cloudflare account management for deploying Workers, KV Storage, R2, Pages, DNS, and Routes. Use when deploying cloudflare services, managing worker containers, configuring KV/R2 storage, or setting up DNS/routing. Requires CLOUDFLARE_API_KEY in .env and Bun runtime with dependencies installed. ",
      "keywords": ["cloudflare-manager","cloudflare","manager","workers","edge","serverless","wrangler","dns"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-mcp-server",
      "source": "./skills/cloudflare-mcp-server",
      "description": "Build MCP (Model Context Protocol) servers on Cloudflare Workers with tools, resources, and prompts. ",
      "keywords": ["cloudflare-mcp-server","cloudflare","mcp","server","workers","edge","serverless","wrangler"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-nextjs",
      "source": "./skills/cloudflare-nextjs",
      "description": "Deploy Next.js applications (App Router and Pages Router) to Cloudflare Workers using the OpenNext adapter. This skill should be used when deploying Next.js apps with SSR, ISR, or server components to Cloudflare's serverless platform. It covers setup for both new and existing projects, configuration requirements, development workflows, integration with Cloudflare services (D1, R2, KV, Workers AI), and prevention of 10+ documented errors including worker size limits, runtime compatibility, database connection scoping, and security vulnerabilities. Keywords: Cloudflare Next.js, OpenNext Cloudflare, @opennextjs/cloudflare, Next.js Workers, Next.js App Router Cloudflare, Next.js Pages Router Cloudflare, Next.js SSR Cloudflare, Next.js ISR, server components cloudflare, server actions cloudflare, Next.js middleware workers, nextjs d1, nextjs r2, nextjs kv, Next.js deployment, opennextjs-cloudflare cli, nodejs_compat, worker size limit, next.js runtime compatibility, database connection scoping, Next.js migration cloudflare ",
      "keywords": ["cloudflare-nextjs","cloudflare","nextjs","workers","edge","serverless","wrangler","isr","ssr","opennext","integration","configuration","deployment","migration"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-queues",
      "source": "./skills/cloudflare-queues",
      "description": "Complete knowledge domain for Cloudflare Queues - flexible message queue for asynchronous processing and background tasks on Cloudflare Workers. Use when: creating message queues, async processing, background jobs, batch processing, handling retries, configuring dead letter queues, implementing consumer concurrency, or encountering \"queue timeout\", \"batch retry\", \"message lost\", \"throughput exceeded\", \"consumer not scaling\" errors. Keywords: cloudflare queues, queues workers, message queue, queue bindings, async processing, background jobs, queue consumer, queue producer, batch processing, dead letter queue, dlq, message retry, queue ack, consumer concurrency, queue backlog, wrangler queues ",
      "keywords": ["cloudflare-queues","cloudflare","queues","workers","edge","serverless","wrangler","async","asynchronous"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-r2",
      "source": "./skills/cloudflare-r2",
      "description": "Complete knowledge domain for Cloudflare R2 - S3-compatible object storage on Cloudflare's edge network. Use when: creating R2 buckets, uploading files to R2, downloading objects, configuring R2 bindings, setting up CORS, generating presigned URLs, multipart uploads, storing images/assets, managing object metadata, or encountering \"R2_ERROR\", CORS errors, presigned URL failures, multipart upload issues, or storage quota errors. Keywords: r2, r2 storage, cloudflare r2, r2 bucket, r2 upload, r2 download, r2 binding, object storage, s3 compatible, r2 cors, presigned urls, multipart upload, r2 api, r2 workers, file upload, asset storage, R2_ERROR, R2Bucket, r2 metadata, custom metadata, http metadata, content-type, cache-control, aws4fetch, s3 client, bulk delete, r2 list, storage class ",
      "keywords": ["cloudflare-r2","cloudflare","workers","edge","serverless","wrangler","cors","url"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-sandbox",
      "source": "./skills/cloudflare-sandbox",
      "description": "This skill provides comprehensive knowledge for building applications with Cloudflare Sandboxes SDK, which enables secure, isolated code execution in full Linux containers at the edge. It should be used when executing untrusted code, running Python/Node.js scripts, performing git operations, building AI code execution systems, creating interactive development environments, or implementing CI/CD workflows that require full OS capabilities. Use when: Setting up Cloudflare Sandboxes, executing Python/Node.js code safely, managing stateful development environments, implementing AI code interpreters, running shell commands in isolation, handling git repositories programmatically, building chat-based coding agents, creating temporary build environments, processing files with system tools (ffmpeg, imagemagick, etc.), or when encountering issues with container lifecycle, session management, or state persistence. Keywords: cloudflare sandbox, container execution, code execution, isolated environment, durable objects, linux container, python execution, node execution, git operations, code interpreter, AI agents, session management, ephemeral container, workspace, sandbox SDK, @cloudflare/sandbox, exec(), getSandbox(), runCode(), gitCheckout(), ubuntu container ",
      "keywords": ["cloudflare-sandbox","cloudflare","sandbox","workers","edge","serverless","wrangler","sdk"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-turnstile",
      "source": "./skills/cloudflare-turnstile",
      "description": "This skill provides comprehensive knowledge for implementing Cloudflare Turnstile, the CAPTCHA-alternative bot protection system. It should be used when integrating bot protection into forms, login pages, signup flows, or any user-facing feature requiring spam/bot prevention. Turnstile runs invisible challenges in the background, maintaining excellent user experience while blocking automated traffic. Use when: Adding bot protection to forms, implementing login security, protecting API endpoints from abuse, migrating from reCAPTCHA/hCaptcha, encountering CSP errors with Turnstile, handling token validation failures, implementing E2E tests with Turnstile, integrating with React/Next.js/Hono applications, or debugging error codes 100*, 300*, 600*. Keywords: turnstile, captcha, bot protection, cloudflare challenge, siteverify, recaptcha alternative, spam prevention, form protection, cf-turnstile, turnstile widget, token validation, managed challenge, invisible challenge, @marsidev/react-turnstile, hono turnstile, workers turnstile ",
      "keywords": ["cloudflare-turnstile","cloudflare","turnstile","workers","edge","serverless","wrangler","api","captcha","csp","e2e","validation"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-vectorize",
      "source": "./skills/cloudflare-vectorize",
      "description": "Complete knowledge domain for Cloudflare Vectorize - globally distributed vector database for building semantic search, RAG (Retrieval Augmented Generation), and AI-powered applications. Use when: creating vector indexes, inserting embeddings, querying vectors, implementing semantic search, building RAG systems, configuring metadata filtering, working with Workers AI embeddings, integrating with OpenAI embeddings, or encountering metadata index timing errors, dimension mismatches, filter syntax issues, or insert vs upsert confusion. Keywords: vectorize, vector database, vector index, vector search, similarity search, semantic search, nearest neighbor, knn search, ann search, RAG, retrieval augmented generation, chat with data, document search, semantic Q&A, context retrieval, bge-base, @cf/baai/bge-base-en-v1.5, text-embedding-3-small, text-embedding-3-large, Workers AI embeddings, openai embeddings, insert vectors, upsert vectors, query vectors, delete vectors, metadata filtering, namespace filtering, topK search, cosine similarity, euclidean distance, dot product, wrangler vectorize, metadata index, create vectorize index, vectorize dimensions, vectorize metric, vectorize binding ",
      "keywords": ["cloudflare-vectorize","cloudflare","vectorize","workers","edge","serverless","wrangler","rag","openai"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-worker-base",
      "source": "./skills/cloudflare-worker-base",
      "description": "Production-tested setup for Cloudflare Workers with Hono, Vite, and Static Assets. Use when: creating new Cloudflare Workers projects, setting up Hono routing with Workers, configuring Vite plugin for Workers, adding Static Assets to Workers, deploying with Wrangler, or encountering deployment errors, routing conflicts, or HMR crashes. Prevents 6 documented issues: export syntax errors, Static Assets routing conflicts, scheduled handler errors, HMR race conditions, upload race conditions, and Service Worker format confusion. Keywords: Cloudflare Workers, CF Workers, Hono, wrangler, Vite, Static Assets, @cloudflare/vite-plugin, wrangler.jsonc, ES Module, run_worker_first, SPA fallback, API routes, serverless, edge computing, \"Cannot read properties of undefined\", \"Static Assets 404\", \"A hanging Promise was canceled\", \"Handler does not export\", deployment fails, routing not working, HMR crashes ",
      "keywords": ["cloudflare-worker-base","cloudflare","worker","base","workers","edge","serverless","wrangler","api","hmr","spa","production","deployment"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-workers-ai",
      "source": "./skills/cloudflare-workers-ai",
      "description": "Complete knowledge domain for Cloudflare Workers AI - Run AI models on serverless GPUs across Cloudflare's global network. Use when: implementing AI inference on Workers, running LLM models, generating text/images with AI, configuring Workers AI bindings, implementing AI streaming, using AI Gateway, integrating with embeddings/RAG systems, or encountering \"AI_ERROR\", rate limit errors, model not found, token limit exceeded, or neurons exceeded errors. Keywords: workers ai, cloudflare ai, ai bindings, llm workers, @cf/meta/llama, workers ai models, ai inference, cloudflare llm, ai streaming, text generation ai, ai embeddings, image generation ai, workers ai rag, ai gateway, llama workers, flux image generation, stable diffusion workers, vision models ai, ai chat completion, AI_ERROR, rate limit ai, model not found, token limit exceeded, neurons exceeded, ai quota exceeded, streaming failed, model unavailable, workers ai hono, ai gateway workers, vercel ai sdk workers, openai compatible workers, workers ai vectorize ",
      "keywords": ["cloudflare-workers-ai","cloudflare","workers","edge","serverless","wrangler","llm","rag","streaming"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-workflows",
      "source": "./skills/cloudflare-workflows",
      "description": "Complete knowledge domain for Cloudflare Workflows - durable execution framework for building multi-step applications on Workers that automatically retry, persist state, and run for hours or days. Use when: creating long-running workflows, implementing retry logic, building event-driven processes, scheduling multi-step tasks, coordinating between APIs, or encountering \"NonRetryableError\", \"I/O context\", \"workflow execution failed\", \"serialization error\", or \"WorkflowEvent not found\" errors. Keywords: cloudflare workflows, workflows workers, durable execution, workflow step, WorkflowEntrypoint, step.do, step.sleep, workflow retries, NonRetryableError, workflow state, wrangler workflows, workflow events, long-running tasks, step.sleepUntil, step.waitForEvent, workflow bindings ",
      "keywords": ["cloudflare-workflows","cloudflare","workflows","workers","edge","serverless","wrangler","nonretryableerror","workflowentrypoint","workflowevent"],
      "category": "cloudflare"
    }
,
    {
      "name": "cloudflare-zero-trust-access",
      "source": "./skills/cloudflare-zero-trust-access",
      "description": "Use this skill when integrating Cloudflare Zero Trust Access authentication with Cloudflare Workers applications. Provides Hono middleware setup, manual JWT validation patterns, service token authentication, CORS handling with Access, and multi-tenant configurations. Prevents 8 common errors including CORS preflight blocking (45 min saved), key cache race conditions (20 min), missing JWT headers (30 min), and dev/prod team mismatches (15 min). Saves ~58% tokens (3,250 tokens) and 2.5 hours per implementation. Covers user authentication flows, service-to-service auth, geographic restrictions, role-based access control, and Access policy configuration. Keywords: Cloudflare Access, Zero Trust, Cloudflare Zero Trust Access, Access authentication, JWT validation, access jwt, service tokens, hono cloudflare access, hono-cloudflare-access middleware, workers authentication, protect worker routes, admin authentication, access policy, identity providers, azure ad access, google workspace access, okta access, github access, rbac cloudflare, geographic restrictions, multi-tenant access, cors access, CORS preflight blocked, JWT header missing, access key cache, team mismatch, access claims ",
      "keywords": ["cloudflare-zero-trust-access","cloudflare","zero","trust","access","workers","edge","serverless","wrangler","cors","jwt","authentication","validation","implementation","configuration"],
      "category": "cloudflare"
    }
,
    {
      "name": "code-review",
      "source": "./skills/code-review",
      "description": "Use when receiving code review feedback (especially if unclear or technically questionable), when completing tasks or major features requiring review before proceeding, or before making any completion/success claims. Covers three practices - receiving feedback with technical rigor over performative agreement, requesting reviews via code-reviewer subagent, and verification gates requiring evidence before any status claims. Essential for subagent-driven development, pull requests, and preventing false completion claims. ",
      "keywords": ["code-review","code","review","development","tooling","workflow"],
      "category": "tooling"
    }
,
    {
      "name": "content-collections",
      "source": "./skills/content-collections",
      "description": "Introduction to Content Collections ",
      "keywords": ["content-collections","content","collections","cms","management","publishing"],
      "category": "cms"
    }
,
    {
      "name": "csrf-protection",
      "source": "./skills/csrf-protection",
      "description": "Implements CSRF protection using synchronizer tokens, double-submit cookies, and SameSite attributes. Use when securing web forms, protecting state-changing endpoints, or implementing defense-in-depth authentication. ",
      "keywords": ["csrf-protection","csrf","protection","security","vulnerability","xss","samesite","authentication"],
      "category": "security"
    }
,
    {
      "name": "database-schema-design",
      "source": "./skills/database-schema-design",
      "description": "Comprehensive database schema design patterns for PostgreSQL and MySQL. Covers normalization (1NF-5NF), relationships (1:1, 1:M, M:M, hierarchical), data types, constraints, audit patterns, and anti-patterns to avoid. Use when designing new databases, reviewing schema designs, planning migrations, choosing data types, defining relationships, implementing audit trails, or troubleshooting schema issues. Prevents 12 documented issues: missing primary keys, no foreign key constraints, VARCHAR(MAX) everywhere, premature denormalization, missing NOT NULL constraints, missing foreign key indexes, wrong data types, missing CHECK constraints, no audit columns, circular dependencies, missing cascade rules, EAV anti-pattern. Production-tested with comprehensive examples and best practices. ",
      "keywords": ["database-schema-design","database","schema","design","orm","sql","storage","query","check","eav","max","not","null","varchar","mysql","postgresql","production","migration"],
      "category": "database"
    }
,
    {
      "name": "database-sharding",
      "source": "./skills/database-sharding",
      "description": "Comprehensive database sharding implementation patterns for PostgreSQL and MySQL. Covers hash-based, range-based, and directory-based sharding strategies, shard key selection, cross-shard queries, rebalancing, and router implementation. Use when scaling beyond single-server capacity, implementing multi-tenant isolation, distributing geographic load, or handling billions of records. Essential for high-traffic applications requiring horizontal scalability. Prevents 10 documented issues: wrong shard key choice (hotspots), missing shard key in queries, cross-shard transactions without handling, hotspot shards from sequential IDs, no rebalancing strategy, timestamp-based sharding hotspots, mutable shard keys, missing shard routing layer, no monitoring for shard balance, incorrect hash function. Production-tested with routers, aggregation patterns, and zero-downtime migration strategies. ",
      "keywords": ["database-sharding","database","sharding","orm","sql","storage","query","mysql","postgresql","production","implementation","migration"],
      "category": "database"
    }
,
    {
      "name": "defense-in-depth-validation",
      "source": "./skills/defense-in-depth-validation",
      "description": "Validate at every layer data passes through to make bugs impossible. Use when invalid data causes failures deep in execution, requiring validation at multiple system layers. ",
      "keywords": ["defense-in-depth-validation","defense","depth","validation","security","vulnerability","protection","csrf","xss"],
      "category": "security"
    }
,
    {
      "name": "dependency-upgrade",
      "source": "./skills/dependency-upgrade",
      "description": "Manage major dependency version upgrades with compatibility analysis, staged rollout, and comprehensive testing. Use when upgrading framework versions, updating major dependencies, or managing breaking changes in libraries. ",
      "keywords": ["dependency-upgrade","dependency","upgrade","development","tooling","workflow"],
      "category": "tooling"
    }
,
    {
      "name": "design-review",
      "source": "./skills/design-review",
      "description": "Conduct comprehensive design reviews on frontend code changes, PRs, and UI implementations using a systematic 7-phase methodology. Evaluates interaction flows, responsiveness, visual polish, accessibility (WCAG 2.1 AA), robustness, and code health with automated browser testing. Use when: reviewing pull requests with UI changes, auditing frontend components for quality, verifying responsive design across viewports, checking accessibility compliance, testing interaction flows and user experience, ensuring visual consistency with design systems, or encountering design issues like poor contrast, broken layouts, accessibility violations, inconsistent spacing, missing focus states, or broken responsive behavior. Requires: Live preview environment, Playwright MCP or Chrome DevTools for automated testing. Keywords: design review, UI audit, frontend review, accessibility audit, WCAG compliance, responsive design, visual QA, UX review, component review, PR design check, layout issues, accessibility violations, contrast problems, broken responsive, interaction bugs, keyboard navigation, focus states, design system compliance, visual consistency, user experience ",
      "keywords": ["design-review","design","review","interface","user-experience","mcp","wcag","devtools","implementation"],
      "category": "design"
    }
,
    {
      "name": "design-system-creation",
      "source": "./skills/design-system-creation",
      "description": "Creates comprehensive design systems with typography, colors, components, and documentation for consistent UI development. Use when establishing design standards, building component libraries, or ensuring cross-team consistency. ",
      "keywords": ["design-system-creation","design","system","creation","interface","user-experience"],
      "category": "design"
    }
,
    {
      "name": "drizzle-orm-d1",
      "source": "./skills/drizzle-orm-d1",
      "description": "Type-safe ORM for Cloudflare D1 databases using Drizzle. This skill provides comprehensive patterns for schema definition, migrations management, type-safe queries, relations, schema design best practices, performance optimization, and Cloudflare Workers integration. Use when: building D1 database schemas, writing type-safe SQL queries, managing database migrations with Drizzle Kit, defining table relations, implementing prepared statements, using D1 batch API for transactions, designing schema indexes, implementing soft deletes, optimizing query performance, testing schema constraints, or encountering \"D1_ERROR\", transaction errors, foreign key constraint failures, migration apply errors, or schema inference issues. Prevents 12 documented issues: D1 transaction errors (SQL BEGIN not supported), foreign key constraint failures during migrations, module import errors with Wrangler, D1 binding not found, migration apply failures, schema TypeScript inference errors, prepared statement caching issues, transaction rollback patterns, TypeScript strict mode errors, drizzle.config.ts not found, remote vs local database confusion, and wrangler.toml vs wrangler.jsonc mixing. Keywords: drizzle orm, drizzle d1, type-safe sql, drizzle schema, drizzle migrations, drizzle kit, orm cloudflare, d1 orm, drizzle typescript, drizzle relations, drizzle transactions, drizzle query builder, schema definition, prepared statements, drizzle batch, migration management, relational queries, drizzle joins, D1_ERROR, BEGIN TRANSACTION d1, foreign key constraint, migration failed, schema not found, d1 binding error, schema design, database indexes, soft deletes, uuid primary keys, enum constraints, performance optimization, naming conventions, schema testing ",
      "keywords": ["drizzle-orm-d1","drizzle","orm","database","sql","storage","query","api","begin","transaction","typescript","optimization","integration","migration","caching"],
      "category": "database"
    }
,
    {
      "name": "elevenlabs-agents",
      "source": "./skills/elevenlabs-agents",
      "description": "Use this skill when building AI voice agents with the ElevenLabs Agents Platform. This skill covers the complete platform including agent configuration (system prompts, turn-taking, workflows), voice & language features (multi-voice, pronunciation, speed control), knowledge base (RAG), tools (client/server/MCP/system), SDKs (React, JavaScript, React Native, Swift, Widget), Scribe (real-time STT), WebRTC/WebSocket connections, testing & evaluation, analytics, privacy/compliance (GDPR/HIPAA/SOC 2), cost optimization, CLI workflows (\"agents as code\"), and DevOps integration. Prevents 17+ common errors including package deprecation, Android audio cutoff, CSP violations, missing dynamic variables, case-sensitive tool names, webhook authentication failures, and WebRTC configuration issues. Provides production-tested templates for React, Next.js, React Native, Swift, and Cloudflare Workers. Token savings: ~73% (22k → 6k tokens). Production tested. Keywords: ElevenLabs Agents, ElevenLabs voice agents, AI voice agents, conversational AI, @elevenlabs/react, @elevenlabs/client, @elevenlabs/react-native, @elevenlabs/elevenlabs-js, @elevenlabs/agents-cli, elevenlabs SDK, voice AI, TTS, text-to-speech, ASR, speech recognition, turn-taking model, WebRTC voice, WebSocket voice, ElevenLabs conversation, agent system prompt, agent tools, agent knowledge base, RAG voice agents, multi-voice agents, pronunciation dictionary, voice speed control, elevenlabs scribe, @11labs deprecated, Android audio cutoff, CSP violation elevenlabs, dynamic variables elevenlabs, case-sensitive tool names, webhook authentication ",
      "keywords": ["elevenlabs-agents","elevenlabs","agents","machine-learning","llm","artificial-intelligence","asr","cli","csp","gdpr","hipaa","mcp","rag","sdk","soc","stt","tts","devops","javascript","webrtc","websocket","production","authentication","optimization","integration","configuration","real-time"],
      "category": "ai"
    }
,
    {
      "name": "fastmcp",
      "source": "./skills/fastmcp",
      "description": "Use this skill when building MCP (Model Context Protocol) servers with FastMCP in Python. FastMCP is a framework for creating servers that expose tools, resources, and prompts to LLMs like Claude. The skill covers server creation, tool/resource definitions, storage backends (memory/disk/Redis/DynamoDB), server lifespans, middleware system (8 built-in types), server composition (import/mount), OAuth Proxy, authentication patterns, icons, OpenAPI integration, client configuration, cloud deployment (FastMCP Cloud), error handling, and production patterns. It prevents 25+ common errors including storage misconfiguration, lifespan issues, middleware order errors, circular imports, module-level server issues, async/await confusion, OAuth security vulnerabilities, and cloud deployment failures. Includes templates for basic servers, storage backends, middleware, server composition, OAuth proxy, API integrations, testing, and self-contained production architectures. Keywords: FastMCP, MCP server Python, Model Context Protocol Python, fastmcp framework, mcp tools, mcp resources, mcp prompts, fastmcp storage, fastmcp memory storage, fastmcp disk storage, fastmcp redis, fastmcp dynamodb, fastmcp lifespan, fastmcp middleware, fastmcp oauth proxy, server composition mcp, fastmcp import, fastmcp mount, fastmcp cloud, fastmcp deployment, mcp authentication, fastmcp icons, openapi mcp, claude mcp server, fastmcp testing, storage misconfiguration, lifespan issues, middleware order, circular imports, module-level server, async await mcp ",
      "keywords": ["fastmcp","development","tooling","workflow","api","mcp","dynamodb","openapi","production","authentication","integration","configuration","deployment","async"],
      "category": "tooling"
    }
,
    {
      "name": "feature-dev",
      "source": "./skills/feature-dev",
      "description": "Automate complete feature development lifecycle with 7-phase guided workflow including codebase exploration, architecture design, and quality review. Use when building complex features, making architectural decisions, integrating with existing code, or clarifying ambiguous requirements. Launches specialized agents (code-explorer, code-architect, code-reviewer) that run in parallel for discovery, design, and review phases. Prevents common mistakes by ensuring understanding before implementation, asking clarifying questions, comparing design approaches, and reviewing for bugs and conventions. Use when: building multi-file features, requiring architectural decisions, integrating with existing patterns, or working with underspecified requirements. Don't use for: single-line fixes, trivial changes, or urgent hotfixes. Keywords: feature development, code exploration, architecture design, code review, workflow automation, slash command, agents, discovery phase, implementation planning, quality review ",
      "keywords": ["feature-dev","feature","dev","development","tooling","workflow","implementation"],
      "category": "tooling"
    }
,
    {
      "name": "firecrawl-scraper",
      "source": "./skills/firecrawl-scraper",
      "description": "Complete knowledge domain for Firecrawl v2 API - web scraping and crawling that converts websites into LLM-ready markdown or structured data. Use when: scraping websites, crawling entire sites, extracting web content, converting HTML to markdown, building web scrapers, handling dynamic JavaScript content, bypassing anti-bot protection, extracting structured data from web pages, or when encountering \"content not loading\", \"JavaScript rendering issues\", or \"blocked by bot detection\". Keywords: firecrawl, firecrawl api, web scraping, web crawler, scrape website, crawl website, extract content, html to markdown, site crawler, content extraction, web automation, firecrawl-py, firecrawl-js, llm ready data, structured data extraction, bot bypass, javascript rendering, scraping api, crawling api, map urls, batch scraping ",
      "keywords": ["firecrawl-scraper","firecrawl","scraper","web","performance","optimization","pwa","api","html","llm","javascript"],
      "category": "web"
    }
,
    {
      "name": "frontend-design",
      "source": "./skills/frontend-design",
      "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics. ",
      "keywords": ["frontend-design","frontend","design","development","tooling","workflow","production"],
      "category": "tooling"
    }
,
    {
      "name": "gemini-cli",
      "source": "./skills/gemini-cli",
      "description": "Use Google Gemini CLI directly from Claude Code for second opinions, architectural advice, debugging help, code reviews, and security audits. Leverage Gemini's 1M+ context window for comprehensive code analysis using the official gemini command-line tool. Use when: Need second opinion on architectural decisions, stuck debugging after 2+ attempts, writing security-sensitive code (auth, payments, data handling), planning large refactors (5+ files), approaching 70%+ context capacity, unfamiliar with technology stack, want to compare Flash vs Pro model recommendations, need comprehensive codebase analysis, or consulting Gemini for peer review on critical code changes. Keywords: gemini-cli, google gemini, gemini command line, second opinion, model comparison, gemini-2.5-flash, gemini-2.5-pro, architectural decisions, debugging assistant, code review gemini, security audit gemini, 1M context window, AI pair programming, gemini consultation, flash vs pro, AI-to-AI prompting, peer review, codebase analysis, gemini CLI tool, shell gemini, command line AI assistant, gemini architecture advice, gemini debug help, gemini security scan, gemini code compare ",
      "keywords": ["gemini-cli","gemini","cli","machine-learning","llm","artificial-intelligence"],
      "category": "ai"
    }
,
    {
      "name": "github-project-automation",
      "source": "./skills/github-project-automation",
      "description": "This skill provides comprehensive automation for GitHub repository setup and configuration. It should be used when creating new projects, setting up CI/CD pipelines, configuring issue templates, enabling security scanning, or migrating existing projects to GitHub automation. The skill prevents 18 documented errors in GitHub Actions YAML syntax, workflow configuration, issue template structure, Dependabot setup, and CodeQL security scanning. It includes 12 production-tested workflow templates, 4 issue templates, security configurations, and automation scripts for rapid project setup. Use when: setting up GitHub Actions CI/CD, creating issue/PR templates, enabling Dependabot, configuring CodeQL scanning, automating GitHub repository setup, fixing YAML syntax errors, integrating security scanning, deploying to Cloudflare Workers via GitHub Actions, or implementing multi-framework testing matrices. Keywords: github actions, github workflow, ci/cd, issue templates, pull request templates, dependabot, codeql, security scanning, yaml syntax, github automation, repository setup, workflow templates, github actions matrix, secrets management, branch protection, codeowners, github projects, continuous integration, continuous deployment, workflow syntax error, action version pinning, runner version, github context, yaml indentation error ",
      "keywords": ["github-project-automation","github","project","automation","development","tooling","workflow","yaml","codeql","production","integration","configuration","deployment"],
      "category": "tooling"
    }
,
    {
      "name": "google-gemini-api",
      "source": "./skills/google-gemini-api",
      "description": "Complete guide for Google Gemini API using the CORRECT current SDK (@google/genai v1.27+, NOT the deprecated @google/generative-ai). Covers text generation, multimodal inputs (text + images + video + audio + PDFs), function calling, thinking mode, streaming, and system instructions with accurate 2025 model information (Gemini 2.5 Pro/Flash/Flash-Lite with 1M input tokens, NOT 2M). Use when: integrating Gemini API, implementing multimodal AI applications, using thinking mode for complex reasoning, function calling with parallel execution, streaming responses, deploying to Cloudflare Workers, building chat applications, or encountering SDK deprecation warnings, context window errors, model not found errors, function calling failures, or multimodal format errors. Keywords: gemini api, @google/genai, gemini-2.5-pro, gemini-2.5-flash, gemini-2.5-flash-lite, multimodal gemini, thinking mode, google ai, genai sdk, function calling gemini, streaming gemini, gemini vision, gemini video, gemini audio, gemini pdf, system instructions, multi-turn chat, DEPRECATED @google/generative-ai, gemini context window, gemini models 2025, gemini 1m tokens, gemini tool use, parallel function calling, compositional function calling ",
      "keywords": ["google-gemini-api","google","gemini","api","machine-learning","llm","artificial-intelligence","correct","deprecated","not","sdk","streaming"],
      "category": "ai"
    }
,
    {
      "name": "google-gemini-embeddings",
      "source": "./skills/google-gemini-embeddings",
      "description": "This skill provides complete coverage of Google Gemini embeddings API (gemini-embedding-001) for building RAG systems, semantic search, document clustering, and similarity matching. Use when implementing vector search with Google's embedding models, integrating with Cloudflare Vectorize, or building retrieval-augmented generation systems. Covers SDK usage (@google/genai), fetch-based Workers implementation, batch processing, 8 task types (RETRIEVAL_QUERY, RETRIEVAL_DOCUMENT, SEMANTIC_SIMILARITY, etc.), dimension optimization (128-3072), and cosine similarity calculations. Prevents 8+ embedding-specific errors including dimension mismatches, incorrect task types, rate limiting issues (100 RPM free tier), vector normalization mistakes, text truncation (2,048 token limit), and model version confusion. Includes production-ready RAG patterns with Cloudflare Vectorize integration, chunking strategies, and caching patterns. Token savings: ~60%. Production tested. Keywords: gemini embeddings, gemini-embedding-001, google embeddings, semantic search, RAG, vector search, document clustering, similarity search, retrieval augmented generation, vectorize integration, cloudflare vectorize embeddings, 768 dimensions, embed content gemini, batch embeddings, embeddings api, cosine similarity, vector normalization, retrieval query, retrieval document, task types, dimension mismatch, embeddings rate limit, text truncation, @google/genai ",
      "keywords": ["google-gemini-embeddings","google","gemini","embeddings","machine-learning","llm","artificial-intelligence","api","rag","rpm","sdk","production","optimization","integration","implementation","caching"],
      "category": "ai"
    }
,
    {
      "name": "google-gemini-file-search",
      "source": "./skills/google-gemini-file-search",
      "description": "Set up Google Gemini File Search for fully managed RAG (Retrieval-Augmented Generation). This skill should be used when building document Q&A systems, searchable knowledge bases, or semantic search with automatic chunking, embedding generation, and citation support. Supports 100+ file formats including PDF, Word, Excel, code files. Prevents common errors: document immutability (delete+re-upload pattern required), storage quota calculation (3x input size for embeddings), chunking configuration (500 tokens/chunk recommended), metadata limits (20 key-value pairs max), indexing cost surprises (one-time $0.15/1M tokens), operation polling (must wait for done: true), force delete requirement (for stores with documents), and model support (only Gemini 2.5 Pro/Flash). TypeScript/JavaScript support via @google/genai SDK. Token savings: ~65%. ",
      "keywords": ["google-gemini-file-search","google","gemini","file","search","machine-learning","llm","artificial-intelligence","pdf","rag","sdk","javascript","typescript","configuration"],
      "category": "ai"
    }
,
    {
      "name": "graphql-implementation",
      "source": "./skills/graphql-implementation",
      "description": "Builds GraphQL APIs with schema design, resolvers, error handling, and performance optimization using Apollo or Graphene. Use when creating flexible query APIs, migrating from REST, or implementing real-time subscriptions. ",
      "keywords": ["graphql-implementation","graphql","implementation","api","rest","endpoints","http","optimization","real-time"],
      "category": "api"
    }
,
    {
      "name": "health-check-endpoints",
      "source": "./skills/health-check-endpoints",
      "description": "Implements health check endpoints for liveness, readiness, and dependency monitoring in Kubernetes and load balancer environments. Use when deploying to container orchestrators, configuring auto-scaling, or monitoring service availability. ",
      "keywords": ["health-check-endpoints","health","check","endpoints","architecture","patterns","microservices","design"],
      "category": "architecture"
    }
,
    {
      "name": "hono-routing",
      "source": "./skills/hono-routing",
      "description": "This skill provides comprehensive knowledge for building type-safe APIs with Hono, focusing on routing patterns, middleware composition, request validation, RPC client/server patterns, error handling, and context management. Use when: building APIs with Hono (any runtime), setting up request validation with Zod/Valibot/Typia/ArkType validators, creating type-safe RPC client/server communication, implementing custom middleware, handling errors with HTTPException, extending Hono context with custom variables, or encountering middleware type inference issues, validation hook confusion, or RPC performance problems. Keywords: hono, hono routing, hono middleware, hono rpc, hono validator, zod validator, valibot validator, type-safe api, hono context, hono error handling, HTTPException, c.req.valid, middleware composition, hono hooks, typed routes, hono client, middleware response not typed, hono validation failed, hono rpc type inference ",
      "keywords": ["hono-routing","hono","routing","web","performance","optimization","pwa","rpc","arktype","validation"],
      "category": "web"
    }
,
    {
      "name": "hugo",
      "source": "./skills/hugo",
      "description": "This skill provides comprehensive knowledge for building static websites with Hugo static site generator. It should be used when setting up Hugo projects (blogs, documentation sites, landing pages, portfolios), integrating Tailwind CSS v4 for custom styling, integrating headless CMS systems (Sveltia CMS or TinaCMS), deploying to Cloudflare Workers with Static Assets, configuring themes and templates, and preventing common Hugo setup errors. Use this skill when encountering these scenarios: scaffolding new Hugo sites, choosing between Hugo Extended and Standard editions, integrating Tailwind CSS v4 with Hugo Pipes, configuring hugo.yaml or hugo.toml files, integrating PaperMod or other themes via Git submodules, setting up Sveltia CMS or TinaCMS for content management, deploying to Cloudflare Workers or Pages, troubleshooting baseURL configuration, resolving theme installation errors, fixing frontmatter format issues (YAML vs TOML), preventing date-related build failures, setting up PostCSS with Hugo, or setting up CI/CD with GitHub Actions. Keywords: hugo, hugo-extended, static-site-generator, ssg, go-templates, papermod, goldmark, markdown, blog, documentation, docs-site, landing-page, sveltia-cms, tina-cms, headless-cms, cloudflare-workers, workers-static-assets, wrangler, hugo-server, hugo-build, frontmatter, yaml-frontmatter, toml-config, hugo-themes, hugo-modules, multilingual, i18n, github-actions, version-mismatch, baseurl-error, theme-not-found, tailwind, tailwind-v4, tailwind-css, hugo-pipes, postcss, css-framework, utility-css, hugo-tailwind, tailwind-integration, hugo-assets ",
      "keywords": ["hugo","cms","content","management","publishing","css","toml","yaml","github","papermod","postcss","tinacms","integration","configuration"],
      "category": "cms"
    }
,
    {
      "name": "idempotency-handling",
      "source": "./skills/idempotency-handling",
      "description": "Implements idempotent API operations using idempotency keys, Redis caching, and database constraints to prevent duplicate processing. Use when building payment systems, handling webhook retries, or ensuring safe operation retries. ",
      "keywords": ["idempotency-handling","idempotency","handling","development","tooling","workflow","api","caching"],
      "category": "tooling"
    }
,
    {
      "name": "image-optimization",
      "source": "./skills/image-optimization",
      "description": "Optimizes images for web performance using modern formats, responsive techniques, and lazy loading strategies. Use when improving page load times, implementing responsive images, or preparing assets for production deployment. ",
      "keywords": ["image-optimization","image","optimization","web","performance","pwa","production","deployment"],
      "category": "web"
    }
,
    {
      "name": "inspira-ui",
      "source": "./skills/inspira-ui",
      "description": "This skill should be used when building Vue or Nuxt applications with animated UI components and effects. Inspira UI provides 120+ production-ready components including backgrounds (aurora, cosmic portal, particles), buttons (shimmer, ripple, rainbow), cards (3D, flip, spotlight), text animations (morphing, glitch, hyper text), special effects (confetti, meteors, neon borders), cursors (fluid, tailed), visualizations (3D globe, carousels, icon cloud), input forms (color picker, file upload), device mocks (iPhone, Safari), and miscellaneous components (dock, timeline, bento grid). Built with TailwindCSS v4, motion-v, GSAP, and Three.js for Vue 3 and Nuxt 4 projects. This skill should be used when implementing animated hero sections, interactive backgrounds, modern UI effects, 3D visualizations, form inputs with effects, testimonial blocks, or any animated web interface components for Vue/Nuxt applications. Prevents common pitfalls with TailwindCSS v4 setup, CSS variables configuration, motion-v integration, component prop typing, and WebGL dependencies. ",
      "keywords": ["inspira-ui","inspira","frontend","components","react","typescript","css","gsap","tailwindcss","webgl","production","integration","configuration"],
      "category": "frontend"
    }
,
    {
      "name": "interaction-design",
      "source": "./skills/interaction-design",
      "description": "Creates intuitive user experiences through feedback patterns, microinteractions, and accessible interaction design. Use when designing loading states, error handling UX, animation guidelines, or touch interactions. ",
      "keywords": ["interaction-design","interaction","design","interface","user-experience"],
      "category": "design"
    }
,
    {
      "name": "internationalization-i18n",
      "source": "./skills/internationalization-i18n",
      "description": "Implements multi-language support using i18next, gettext, or Intl API with translation workflows and RTL support. Use when building multilingual applications, handling date/currency formatting, or supporting right-to-left languages. ",
      "keywords": ["internationalization-i18n","internationalization","i18n","web","performance","optimization","pwa","api","rtl"],
      "category": "web"
    }
,
    {
      "name": "jest-generator",
      "source": "./skills/jest-generator",
      "description": "Generate Jest-based unit tests for JavaScript/TypeScript code. Creates test files following Jest conventions with proper mocking, describe blocks, and coverage. Use when generating tests for JS/TS modules, React components, or adding missing test coverage. ",
      "keywords": ["jest-generator","jest","generator","testing","tests","unit-tests","integration","quality","javascript","typescript"],
      "category": "testing"
    }
,
    {
      "name": "kpi-dashboard-design",
      "source": "./skills/kpi-dashboard-design",
      "description": "Designs effective KPI dashboards with proper metric selection, visual hierarchy, and data visualization best practices. Use when building executive dashboards, creating analytics views, or presenting business metrics. ",
      "keywords": ["kpi-dashboard-design","kpi","dashboard","design","interface","user-experience"],
      "category": "design"
    }
,
    {
      "name": "logging-best-practices",
      "source": "./skills/logging-best-practices",
      "description": "Implements structured logging with proper levels, contextual information, PII handling, and centralized aggregation. Use when setting up application logging, integrating with log management systems, or implementing distributed tracing. ",
      "keywords": ["logging-best-practices","logging","best","practices","development","tooling","workflow","pii"],
      "category": "tooling"
    }
,
    {
      "name": "mcp-dynamic-orchestrator",
      "source": "./skills/mcp-dynamic-orchestrator",
      "description": "This skill provides dynamic discovery and code-mode execution for MCP servers defined in a central registry file. It should be used when an agent needs to know which MCP integrations are available, what domains they cover, and how to call them efficiently via generated code without eagerly loading each MCP tool as a first-class tool. Use when: working with multiple MCP servers (APIs, internal systems, SaaS tools), especially when the set of available MCPs changes over time or is large enough that exposing all tools directly would bloat context. Keywords: MCP, code-mode, registry, dynamic tools, tool discovery, progressive disclosure ",
      "keywords": ["mcp-dynamic-orchestrator","mcp","dynamic","orchestrator","development","tooling","workflow","saas","integration"],
      "category": "tooling"
    }
,
    {
      "name": "mcp-management",
      "source": "./skills/mcp-management",
      "description": "Manage Model Context Protocol (MCP) servers - discover, analyze, and execute tools/prompts/resources from configured MCP servers. Use when working with MCP integrations, need to discover available MCP capabilities, filter MCP tools for specific tasks, execute MCP tools programmatically, access MCP prompts/resources, or implement MCP client functionality. Supports intelligent tool selection, multi-server management, and context-efficient capability discovery. ",
      "keywords": ["mcp-management","mcp","management","development","tooling","workflow","integration"],
      "category": "tooling"
    }
,
    {
      "name": "microservices-patterns",
      "source": "./skills/microservices-patterns",
      "description": "Design microservices architectures with service boundaries, event-driven communication, and resilience patterns. Use when building distributed systems, decomposing monoliths, or implementing microservices. ",
      "keywords": ["microservices-patterns","microservices","patterns","architecture","design"],
      "category": "architecture"
    }
,
    {
      "name": "ml-model-training",
      "source": "./skills/ml-model-training",
      "description": "Trains machine learning models with data preparation, algorithm selection, and evaluation using scikit-learn, PyTorch, and TensorFlow. Use when building predictive models, implementing classification/regression, training neural networks, fine-tuning hyperparameters, or evaluating model performance. ",
      "keywords": ["ml-model-training","model","training","machine-learning","llm","artificial-intelligence","pytorch","tensorflow"],
      "category": "ai"
    }
,
    {
      "name": "ml-pipeline-automation",
      "source": "./skills/ml-pipeline-automation",
      "description": "Automates ML workflows from data ingestion to deployment using Airflow, Kubeflow, and MLflow orchestration. Use when building reproducible ML pipelines, scheduling retraining jobs, implementing MLOps practices, orchestrating model training at scale, or tracking experiments across teams. ",
      "keywords": ["ml-pipeline-automation","pipeline","automation","machine-learning","llm","artificial-intelligence","deployment"],
      "category": "ai"
    }
,
    {
      "name": "mobile-app-debugging",
      "source": "./skills/mobile-app-debugging",
      "description": "Debugs mobile applications across iOS, Android, and cross-platform frameworks using platform-specific tools and techniques. Use when diagnosing crashes, memory leaks, performance issues, or network problems in mobile apps. ",
      "keywords": ["mobile-app-debugging","mobile","app","debugging","ios","android","native"],
      "category": "mobile"
    }
,
    {
      "name": "mobile-app-testing",
      "source": "./skills/mobile-app-testing",
      "description": "Implements comprehensive mobile testing strategies including unit tests, UI automation, and performance testing across platforms. Use when setting up test infrastructure, writing E2E tests, or establishing testing standards for mobile apps. ",
      "keywords": ["mobile-app-testing","mobile","app","testing","ios","android","native","e2e"],
      "category": "mobile"
    }
,
    {
      "name": "mobile-first-design",
      "source": "./skills/mobile-first-design",
      "description": "Designs responsive interfaces starting from mobile screens with progressive enhancement for larger devices. Use when building responsive websites, optimizing for mobile users, or implementing adaptive layouts. ",
      "keywords": ["mobile-first-design","mobile","first","design","ios","android","app","native"],
      "category": "mobile"
    }
,
    {
      "name": "mobile-offline-support",
      "source": "./skills/mobile-offline-support",
      "description": "Implements offline-first mobile applications with local storage, sync queues, and conflict resolution strategies. Use when building apps that must work without connectivity, implementing data sync, or handling offline scenarios. ",
      "keywords": ["mobile-offline-support","mobile","offline","support","ios","android","app","native"],
      "category": "mobile"
    }
,
    {
      "name": "model-deployment",
      "source": "./skills/model-deployment",
      "description": "Deploys ML models to production using FastAPI REST APIs, Docker containers, Kubernetes, and model serving platforms with monitoring, drift detection, A/B testing, and CI/CD automation. Use when serving predictions via API, containerizing models, implementing model versioning, deploying to Kubernetes, monitoring model performance, detecting data/prediction drift, or setting up automated ML pipelines. ",
      "keywords": ["model-deployment","model","deployment","machine-learning","llm","artificial-intelligence","api","rest","fastapi","production"],
      "category": "ai"
    }
,
    {
      "name": "motion",
      "source": "./skills/motion",
      "description": "Production-ready setup for Motion (formerly Framer Motion) - the most popular React animation library with 30,200+ GitHub stars. Motion provides declarative animations, gesture controls, scroll-based effects, spring physics, layout animations, and SVG manipulation. This skill should be used when building UIs that need complex animations beyond simple list transitions: gesture controls (drag, hover, tap), scroll-linked animations, parallax effects, shared element transitions, SVG path morphing, spring physics, or orchestrated animation sequences. Use when: Adding drag-and-drop interactions, creating scroll-triggered animations, implementing modal dialogs with sophisticated transitions, building carousels with momentum, animating page/route transitions, creating hero sections with parallax, implementing accordion components with smooth expand/collapse, or optimizing animation bundle size with LazyMotion. **Important**: For simple list add/remove/sort animations, use the `auto-animate` skill instead (3.28 KB vs 34 KB bundle). Motion is designed for complex interactive animations that require fine-grained control. ",
      "keywords": ["motion","frontend","components","react","typescript","svg","github","lazymotion","production"],
      "category": "frontend"
    }
,
    {
      "name": "multi-ai-consultant",
      "source": "./skills/multi-ai-consultant",
      "description": "Consult external AIs (Gemini 2.5 Pro, OpenAI Codex, fresh Claude) for second opinions when stuck on bugs or making architectural decisions. Use when: debugging attempts have failed, making significant architectural choices, security concerns, or need fresh perspective. Automatically suggests consultation after one failed attempt. Provides synthesis comparing multiple AI perspectives with web research, thinking mode, and repo-aware analysis. ",
      "keywords": ["multi-ai-consultant","multi","consultant","machine-learning","llm","artificial-intelligence","openai"],
      "category": "ai"
    }
,
    {
      "name": "mutation-testing",
      "source": "./skills/mutation-testing",
      "description": "Validate test effectiveness with mutation testing using Stryker (TypeScript/JavaScript) and mutmut (Python). Find weak tests that pass despite code mutations. Use to improve test quality. ",
      "keywords": ["mutation-testing","mutation","testing","tests","unit-tests","integration","quality","javascript","typescript"],
      "category": "testing"
    }
,
    {
      "name": "nano-banana-prompts",
      "source": "./skills/nano-banana-prompts",
      "description": "Generate optimized prompts for Gemini 2.5 Flash Image (Nano Banana). Use when user wants to create images with Gemini, needs help crafting image prompts, or requests \"nano banana\" style prompts. Applies proven best practices for natural language descriptions, photography, art styles, and multi-turn editing workflows. ",
      "keywords": ["nano-banana-prompts","nano","banana","prompts","development","tooling","workflow"],
      "category": "tooling"
    }
,
    {
      "name": "neon-vercel-postgres",
      "source": "./skills/neon-vercel-postgres",
      "description": "This skill provides comprehensive knowledge for integrating Neon serverless Postgres and Vercel Postgres (which is built on Neon infrastructure) into web applications. It should be used when setting up serverless Postgres databases, configuring connection pooling for edge and serverless environments, implementing database branching workflows, or troubleshooting Postgres connection issues in Cloudflare Workers, Vercel Edge Functions, or Node.js serverless functions. Use this skill when: - Setting up Neon Postgres for Cloudflare Workers, Vercel Edge, or serverless environments - Configuring Vercel Postgres for Next.js applications - Implementing database branching workflows (git-like database branches) - Integrating Drizzle ORM or Prisma with Neon/Vercel Postgres - Debugging connection pool errors, transaction timeouts, or SSL configuration issues - Migrating from D1/SQLite to Postgres or from traditional Postgres to serverless Postgres - Setting up point-in-time restore (PITR) or database backups - Encountering errors like \"connection pool exhausted\", \"TCP connections not supported in serverless\", or \"sslmode required\" Keywords: neon postgres, @neondatabase/serverless, @vercel/postgres, serverless postgres, postgres edge, neon branching, vercel database, http postgres, websocket postgres, pooled connection, drizzle neon, prisma neon, postgres cloudflare, postgres vercel edge, sql template tag, neonctl, database branches, point in time restore, postgres migrations, serverless sql, edge database, neon api, vercel sql ",
      "keywords": ["neon-vercel-postgres","neon","vercel","postgres","database","orm","sql","storage","query","pitr","ssl","tcp","configuration","migration","serverless","edge"],
      "category": "database"
    }
,
    {
      "name": "nextjs",
      "source": "./skills/nextjs",
      "description": "Use this skill for Next.js App Router patterns, Server Components, Server Actions, Cache Components, and framework-level optimizations. Covers Next.js 16 breaking changes including async params, proxy.ts migration, Cache Components with \"use cache\", and React 19.2 integration. For deploying to Cloudflare Workers, use the cloudflare-nextjs skill instead. This skill is deployment-agnostic and works with Vercel, AWS, self-hosted, or any platform. Keywords: Next.js 16, Next.js App Router, Next.js Pages Router, Server Components, React Server Components, Server Actions, Cache Components, use cache, Next.js 16 breaking changes, async params nextjs, proxy.ts migration, React 19.2, Next.js metadata, Next.js SEO, generateMetadata, static generation, dynamic rendering, streaming SSR, Suspense, parallel routes, intercepting routes, route groups, Next.js middleware, Next.js API routes, Route Handlers, revalidatePath, revalidateTag, next/navigation, useSearchParams, turbopack, next.config ",
      "keywords": ["nextjs","frontend","components","react","typescript","api","aws","seo","ssr","optimization","integration","deployment","migration","streaming","async"],
      "category": "frontend"
    }
,
    {
      "name": "nuxt-content",
      "source": "./skills/nuxt-content",
      "description": "My first Nuxt Content page ",
      "keywords": ["nuxt-content","nuxt","content","frontend","components","react","typescript"],
      "category": "frontend"
    }
,
    {
      "name": "nuxt-seo",
      "source": "./skills/nuxt-seo",
      "description": "Comprehensive guide for all 8 Nuxt SEO modules: @nuxtjs/seo, nuxt-robots, nuxt-sitemap, nuxt-og-image, nuxt-schema-org, nuxt-link-checker, nuxt-seo-utils, and nuxt-site-config. Use when building SEO-optimized Nuxt applications, implementing robots.txt and sitemaps, generating Open Graph images, adding Schema.org structured data, managing meta tags, checking links, or configuring site-wide SEO settings. Covers latest versions (v3+/v4+) with Bun/npm/pnpm package managers. Prevents common SEO configuration errors, sitemap generation issues, OG image rendering problems, and robots.txt misconfigurations. ",
      "keywords": ["nuxt-seo","nuxt","seo","frontend","components","react","typescript","configuration"],
      "category": "frontend"
    }
,
    {
      "name": "nuxt-ui-v4",
      "source": "./skills/nuxt-ui-v4",
      "description": "Production-ready Nuxt UI v4 component library for Nuxt v4 with 100+ accessible components, Tailwind CSS v4, and Reka UI foundation. Use when: setting up Nuxt v4 projects with UI component library, implementing design systems with semantic colors, building accessible forms and data displays, configuring dark mode and color themes, creating responsive layouts with Cards and Containers, implementing navigation with Tabs and CommandPalette, building overlays with Modal/Drawer/Popover/DropdownMenu, adding feedback with Toast/Alert/Skeleton/Progress, integrating AI chat interfaces with AI SDK v5, customizing component themes globally or per-instance, or encountering component rendering issues, theming problems, composable errors (useToast, useNotification), TypeScript errors, or responsive pattern challenges. Covers: Nuxt v4 setup, @nuxt/ui module installation, semantic color system (7 color aliases), component theming with Tailwind Variants, form components and validation, data display with Tables and Cards, navigation patterns (Tabs, Breadcrumb, CommandPalette), overlay components (Modal, Drawer, Dialog, Popover, DropdownMenu, Tooltip), feedback patterns (Toast, Alert, Skeleton, Progress), layout components (Card, Container, Avatar, Badge), composables (useToast, useNotification, useColorMode, defineShortcuts), AI SDK v5 integration, dark mode setup, accessibility with Reka UI, responsive patterns, TypeScript configuration, and 20+ common errors with solutions. Keywords: Nuxt v4, Nuxt 4, Nuxt UI v4, Nuxt UI 4, @nuxt/ui, Tailwind v4, Tailwind CSS 4, Reka UI, semantic colors, design system, accessible components, ARIA, WAI-ARIA, dark mode, color mode, theming, component library, form validation, Input, InputDate, InputTime, date picker, time picker, @internationalized/date, Select, Checkbox, Radio, Textarea, Table, Card, Container, Avatar, Badge, Button, Tabs, Breadcrumb, CommandPalette, Pagination, Modal, Drawer, Dialog, Popover, DropdownMenu, Tooltip, Sheet, Alert, Toast, Notification, Progress, Skeleton, Empty, empty state, Carousel, useToast, useNotification, useColorMode, defineShortcuts, UApp wrapper, Tailwind Variants, Tailwind prefix, component customization, component detection, virtualization, tree-shaking, responsive design, mobile patterns, AI SDK v5, chat interface, Zod validation, nested forms, file uploads, keyboard navigation, focus management, CSS variables, Embla carousel, Fuse.js search, template refs, $el accessor, v4.2 migration ",
      "keywords": ["nuxt-ui-v4","nuxt","frontend","components","react","typescript","aria","css","sdk","wai","commandpalette","dropdownmenu","inputdate","inputtime","production","validation","integration","configuration","migration"],
      "category": "frontend"
    }
,
    {
      "name": "nuxt-v4",
      "source": "./skills/nuxt-v4",
      "description": "Production-ready Nuxt 4 framework development with SSR, composables, data fetching, server routes, and Cloudflare deployment. Use when: building Nuxt 4 applications, implementing SSR patterns, creating composables, server routes, middleware, data fetching, state management, debugging hydration issues, deploying to Cloudflare, optimizing performance, or setting up testing with Vitest. Keywords: Nuxt 4, Nuxt v4, SSR, universal rendering, Nitro, Vue 3, useState, useFetch, useAsyncData, $fetch, composables, auto-imports, middleware, server routes, API routes, hydration, file-based routing, app directory, SEO, meta tags, useHead, useSeoMeta, transitions, error handling, runtime config, Cloudflare Pages, Cloudflare Workers, NuxtHub, Workers Assets, D1, KV, R2, Durable Objects, Vitest, testing, performance optimization, lazy loading, code splitting, prerendering, layers, modules, plugins, Vite, TypeScript, hydration mismatch, shallow reactivity, reactive keys, singleton pattern, defineNuxtConfig, defineEventHandler, navigateTo, definePageMeta, useRuntimeConfig, app.vue, server directory, public directory, assets directory ",
      "keywords": ["nuxt-v4","nuxt","frontend","components","react","typescript","api","seo","ssr","nuxthub","production","optimization","deployment"],
      "category": "frontend"
    }
,
    {
      "name": "oauth-implementation",
      "source": "./skills/oauth-implementation",
      "description": "Implements OAuth 2.0 and OpenID Connect flows for authentication and authorization with proper security measures. Use when integrating third-party providers, building SSO systems, or securing API access with token-based authentication. ",
      "keywords": ["oauth-implementation","oauth","implementation","authentication","authorization","login","security","session","api","sso","openid"],
      "category": "auth"
    }
,
    {
      "name": "open-source-contributions",
      "source": "./skills/open-source-contributions",
      "description": "Use this skill when contributing code to open source projects. The skill covers proper pull request creation, avoiding common mistakes that annoy maintainers, cleaning up personal development artifacts before submission, writing effective PR descriptions, following project conventions, and communicating professionally with maintainers. It prevents 16 common contribution mistakes including working on main branch, not testing before PR submission, including unrelated changes, submitting planning documents, session notes, temporary test files, screenshots, and other personal artifacts. Includes 3 Critical Workflow Rules that must NEVER be skipped: (1) Always work on feature branches, (2) Test thoroughly with evidence before PR, (3) Keep PRs focused on single feature. The skill includes automation scripts to validate PRs before submission, templates for PR descriptions and commit messages, and comprehensive checklists. This skill should be used whenever creating pull requests for public repositories, contributing to community projects, or submitting code to projects you don't own. Keywords: open source contributions, github pull request, PR best practices, contribution guidelines, feature branch workflow, PR description, commit messages, open source etiquette, maintainer-friendly PR, PR checklist, clean PR, avoid personal artifacts, session notes cleanup, planning docs cleanup, test before PR, unrelated changes, working on main branch, focused PR, single feature PR, professional communication, community contributions, public repository contributions, fork workflow, upstream sync ",
      "keywords": ["open-source-contributions","open","source","contributions","development","tooling","workflow","never"],
      "category": "tooling"
    }
,
    {
      "name": "openai-agents",
      "source": "./skills/openai-agents",
      "description": "Use this skill when building AI applications with OpenAI Agents SDK for JavaScript/TypeScript. The skill covers both text-based agents and realtime voice agents, including multi-agent workflows (handoffs), tools with Zod schemas, input/output guardrails, structured outputs, streaming, human-in-the-loop patterns, and framework integrations for Cloudflare Workers, Next.js, and React. It prevents 9+ common errors including Zod schema type errors, MCP tracing failures, infinite loops, tool call failures, and schema mismatches. The skill includes comprehensive templates for all agent types, error handling patterns, and debugging strategies. Keywords: OpenAI Agents SDK, @openai/agents, @openai/agents-realtime, openai agents javascript, openai agents typescript, text agents, voice agents, realtime agents, multi-agent workflows, agent handoffs, agent tools, zod schemas agents, structured outputs agents, agent streaming, agent guardrails, input guardrails, output guardrails, human-in-the-loop, cloudflare workers agents, nextjs openai agents, react openai agents, hono agents, agent debugging, Zod schema type error, MCP tracing failure, agent infinite loop, tool call failures, schema mismatch agents ",
      "keywords": ["openai-agents","openai","agents","machine-learning","llm","artificial-intelligence","mcp","sdk","javascript","typescript","integration","streaming","realtime"],
      "category": "ai"
    }
,
    {
      "name": "openai-api",
      "source": "./skills/openai-api",
      "description": "Complete guide for OpenAI APIs: Chat Completions (GPT-5, GPT-4o), Embeddings, Images (DALL-E 3), Audio (Whisper + TTS), Moderation. Includes Node.js SDK and fetch approaches. ",
      "keywords": ["openai-api","openai","api","machine-learning","llm","artificial-intelligence","dall","gpt","sdk","tts"],
      "category": "ai"
    }
,
    {
      "name": "openai-assistants",
      "source": "./skills/openai-assistants",
      "description": "Complete guide for OpenAI's Assistants API v2: stateful conversational AI with built-in tools (Code Interpreter, File Search, Function Calling), vector stores for RAG (up to 10,000 files), thread/run lifecycle management, and streaming patterns. Both Node.js SDK and fetch approaches. ⚠️ DEPRECATION NOTICE: OpenAI plans to sunset Assistants API in H1 2026 in favor of Responses API. This skill remains valuable for existing apps and migration planning. Use when: building stateful chatbots with OpenAI, implementing RAG with vector stores, executing Python code with Code Interpreter, using file search for document Q&A, managing conversation threads, streaming assistant responses, or encountering errors like \"thread already has active run\", vector store indexing delays, run polling timeouts, or file upload issues. Keywords: openai assistants, assistants api, openai threads, openai runs, code interpreter assistant, file search openai, vector store openai, openai rag, assistant streaming, thread persistence, stateful chatbot, thread already has active run, run status polling, vector store error ",
      "keywords": ["openai-assistants","openai","assistants","machine-learning","llm","artificial-intelligence","api","deprecation","notice","rag","sdk","migration","streaming"],
      "category": "ai"
    }
,
    {
      "name": "openai-responses",
      "source": "./skills/openai-responses",
      "description": "This skill provides comprehensive knowledge for working with OpenAI's Responses API, the unified stateful API for building agentic applications. It should be used when building AI agents that preserve reasoning across turns, integrating MCP servers for external tools, using built-in tools (Code Interpreter, File Search, Web Search, Image Generation), managing stateful conversations, implementing background processing, or migrating from Chat Completions API. Use when building agentic workflows, conversational AI with memory, tools-based applications, RAG systems, data analysis agents, or any application requiring OpenAI's reasoning models with persistent state. Covers both Node.js SDK and Cloudflare Workers implementations. Keywords: responses api, openai responses, stateful openai, openai mcp, code interpreter openai, file search openai, web search openai, image generation openai, reasoning preservation, agentic workflows, conversation state, background mode, chat completions migration, gpt-5, polymorphic outputs ",
      "keywords": ["openai-responses","openai","responses","machine-learning","llm","artificial-intelligence","api","mcp","rag","sdk","implementation","migration"],
      "category": "ai"
    }
,
    {
      "name": "payment-gateway-integration",
      "source": "./skills/payment-gateway-integration",
      "description": "Integrates payment processing with Stripe, PayPal, or Square including subscriptions, webhooks, and PCI compliance. Use when implementing checkout flows, recurring billing, or handling refunds and disputes. ",
      "keywords": ["payment-gateway-integration","payment","gateway","integration","web","performance","optimization","pwa","pci","paypal","webhooks"],
      "category": "web"
    }
,
    {
      "name": "pinia-colada",
      "source": "./skills/pinia-colada",
      "description": "This skill provides comprehensive knowledge for Pinia Colada, the smart data fetching layer for Vue.js built on top of Pinia. It should be used when setting up async data fetching with useQuery, implementing mutations with useMutation, configuring query cache, managing server state, implementing optimistic updates, using paginated queries, configuring SSR/Nuxt integration, or encountering query/mutation errors. Use when: initializing Pinia Colada in Vue 3 or Nuxt projects, configuring PiniaColada plugin settings, creating reusable query composables, implementing mutations with automatic invalidation, setting up optimistic updates, using paginated queries, prefetching data, migrating from TanStack Vue Query, debugging cache issues, fixing SSR hydration errors, implementing query invalidation strategies, or setting up custom plugins for auto-refetch behavior. Keywords: Pinia Colada, @pinia/colada, useQuery, useMutation, useQueryCache, data fetching, async state, Vue 3, Nuxt, Pinia, server state, caching, staleTime, gcTime, query invalidation, prefetching, optimistic updates, mutations, query keys, paginated queries, SSR, server-side rendering, Nuxt module, @pinia/colada-nuxt, query cache, auto-refetch, cache invalidation, request deduplication, loading states, error handling, onSettled, onSuccess, onError, defineColadaLoader ",
      "keywords": ["pinia-colada","pinia","colada","frontend","components","react","typescript","ssr","piniacolada","tanstack","integration","caching","async"],
      "category": "frontend"
    }
,
    {
      "name": "pinia-v3",
      "source": "./skills/pinia-v3",
      "description": "This skill provides comprehensive knowledge for building Vue 3 applications with Pinia, the official state management library. It should be used when setting up Pinia stores, managing state in Vue applications, migrating from Vuex to Pinia, configuring SSR with Pinia, or encountering state management issues in Vue projects. Use when: creating Pinia stores, defining state/getters/actions, setting up Pinia with Nuxt, implementing store composition, configuring plugins, testing stores, using Pinia with Options API, handling SSR state hydration, migrating from Vuex, or debugging store-related errors. Keywords: pinia, vue state management, pinia stores, defineStore, vue 3 state, state management, getters, actions, pinia plugins, pinia ssr, nuxt pinia, vuex migration, store composition, pinia testing, setup stores, option stores, storeToRefs, mapState, mapActions, state hydration, pinia nuxt module, createPinia, useStore, pinia devtools, pinia hmr, hot module replacement ",
      "keywords": ["pinia-v3","pinia","frontend","components","react","typescript","api","ssr","migration"],
      "category": "frontend"
    }
,
    {
      "name": "playwright-testing",
      "source": "./skills/playwright-testing",
      "description": "End-to-end testing with Playwright. Cross-browser testing, visual regression, API testing, and component testing. Use for E2E tests in TypeScript/JavaScript and Python projects. ",
      "keywords": ["playwright-testing","playwright","testing","tests","unit-tests","integration","quality","api","e2e","javascript","typescript"],
      "category": "testing"
    }
,
    {
      "name": "progressive-web-app",
      "source": "./skills/progressive-web-app",
      "description": "Builds Progressive Web Apps with service workers, web manifest, offline support, and installation prompts. Use when creating installable web experiences, implementing offline functionality, or adding push notifications to web apps. ",
      "keywords": ["progressive-web-app","progressive","web","app","performance","optimization","pwa"],
      "category": "web"
    }
,
    {
      "name": "project-planning",
      "source": "./skills/project-planning",
      "description": "Generates comprehensive planning documentation for web application projects, structuring work into context-safe phases with built-in verification criteria. Creates IMPLEMENTATION_PHASES.md, DATABASE_SCHEMA.md, API_ENDPOINTS.md, ARCHITECTURE.md, and other planning docs based on project needs. Optimized for Cloudflare Workers + Vite + React stack. Use when starting new projects, adding major features, or restructuring existing work into manageable phases. Keywords: project planning, planning documentation, IMPLEMENTATION_PHASES.md, DATABASE_SCHEMA.md, API_ENDPOINTS.md, ARCHITECTURE.md, UI_COMPONENTS.md, TESTING.md, AGENTS_CONFIG.md, phased development, context-safe phases, verification criteria, exit criteria, planning docs generator, web app planning, Cloudflare Workers planning, Vite React planning, project structure, project phases, major features planning, new project setup ",
      "keywords": ["project-planning","project","planning","development","tooling","workflow","architecture","testing","implementation"],
      "category": "tooling"
    }
,
    {
      "name": "project-session-management",
      "source": "./skills/project-session-management",
      "description": "Manages session state and context handoffs for multi-session projects using the Session Handoff Protocol. Creates and maintains SESSION.md to track phase progress, git checkpoints, and next actions across context clears. Integrates with project-planning skill to convert IMPLEMENTATION_PHASES.md into trackable session state. Use when starting new projects after planning, resuming work after context clear, or managing complex multi-phase implementations. Keywords: session management, SESSION.md, session handoff protocol, context handoff, multi-session projects, phase tracking, git checkpoints, session state tracking, resume work, context clear, phase progress tracking, implementation phases, verification stage, debugging stage, next action tracking, work continuity, session recovery, context management, phased implementation tracking ",
      "keywords": ["project-session-management","project","session","management","development","tooling","workflow","implementation"],
      "category": "tooling"
    }
,
    {
      "name": "project-workflow",
      "source": "./skills/project-workflow",
      "description": "Automate complete project lifecycle from idea exploration to safe deployment with 7 integrated slash commands. Use when starting projects, planning features, managing development sessions, or ensuring safe releases. Includes /explore-idea, /plan-project, /add-feature, /start-session, /end-session, /safe-merge, /prepare-release commands. Saves 35-55 minutes per project by automating repetitive tasks and enforcing best practices for context management, planning documentation, and release safety checks. Keywords: project workflow, lifecycle automation, slash commands, planning, session management, release safety, implementation phases ",
      "keywords": ["project-workflow","project","workflow","development","tooling","implementation","deployment"],
      "category": "tooling"
    }
,
    {
      "name": "push-notification-setup",
      "source": "./skills/push-notification-setup",
      "description": "Implements push notifications across iOS, Android, and web using Firebase Cloud Messaging and native services. Use when adding notification capabilities, handling background messages, or setting up notification channels. ",
      "keywords": ["push-notification-setup","push","notification","setup","web","performance","optimization","pwa"],
      "category": "web"
    }
,
    {
      "name": "react-hook-form-zod",
      "source": "./skills/react-hook-form-zod",
      "description": "This skill provides comprehensive knowledge for building type-safe, validated forms in React using React Hook Form and Zod schema validation. Use when: building forms with validation in React, integrating Zod schema validation with React Hook Form, using shadcn/ui Form or Field components, implementing client and server-side validation with a single schema, handling complex validation scenarios (nested objects, arrays, conditional fields, async validation), building multi-step forms or wizards, implementing dynamic form fields with useFieldArray, optimizing form performance and re-renders, ensuring accessible form error handling, or debugging form validation issues. Keywords: react-hook-form, useForm, zod validation, zodResolver, @hookform/resolvers, form schema, register, handleSubmit, formState, useFieldArray, useWatch, useController, Controller, shadcn form, Field component, client server validation, nested validation, array field validation, dynamic fields, multi-step form, async validation, zod refine, z.infer, form error handling, uncontrolled to controlled, resolver not found, schema validation error ",
      "keywords": ["react-hook-form-zod","react","hook","form","zod","frontend","components","typescript","validation","async"],
      "category": "frontend"
    }
,
    {
      "name": "react-native-app",
      "source": "./skills/react-native-app",
      "description": "Builds cross-platform mobile applications using React Native with navigation, state management, and native features. Use when developing iOS/Android apps from a single codebase, prototyping mobile solutions, or sharing code with React web apps. ",
      "keywords": ["react-native-app","react","native","app","mobile","ios","android"],
      "category": "mobile"
    }
,
    {
      "name": "recommendation-engine",
      "source": "./skills/recommendation-engine",
      "description": "Builds recommendation systems using collaborative filtering, matrix factorization, content-based, and hybrid approaches for personalized suggestions. Use when implementing product recommendations, content discovery, personalization features, handling cold start problems, or evaluating recommendation quality with precision@k, NDCG, and coverage metrics. ",
      "keywords": ["recommendation-engine","recommendation","engine","data","analytics","processing","sql","queries","ndcg"],
      "category": "data"
    }
,
    {
      "name": "recommendation-system",
      "source": "./skills/recommendation-system",
      "description": "Designs and deploys production recommendation systems with feature stores, caching, A/B testing, and monitoring. Use when building personalization features, implementing real-time recommendations, optimizing for low latency, conducting recommendation experiments, or monitoring recommendation quality at scale. ",
      "keywords": ["recommendation-system","recommendation","system","data","analytics","processing","sql","queries","production","caching","real-time"],
      "category": "data"
    }
,
    {
      "name": "responsive-web-design",
      "source": "./skills/responsive-web-design",
      "description": "Builds adaptive web interfaces using Flexbox, CSS Grid, and media queries with a mobile-first approach. Use when creating multi-device layouts, implementing flexible UI systems, or ensuring cross-browser compatibility. ",
      "keywords": ["responsive-web-design","responsive","web","design","performance","optimization","pwa","css"],
      "category": "web"
    }
,
    {
      "name": "rest-api-design",
      "source": "./skills/rest-api-design",
      "description": "Designs RESTful APIs with proper resource naming, HTTP methods, status codes, and response formats. Use when building new APIs, establishing API conventions, or designing developer-friendly interfaces. ",
      "keywords": ["rest-api-design","rest","api","design","graphql","endpoints","http"],
      "category": "api"
    }
,
    {
      "name": "root-cause-tracing",
      "source": "./skills/root-cause-tracing",
      "description": "Systematically trace bugs backward through call stack to find original trigger. Use when errors occur deep in execution and you need to trace back to find the original trigger. ",
      "keywords": ["root-cause-tracing","root","cause","tracing","development","tooling","workflow"],
      "category": "tooling"
    }
,
    {
      "name": "security-headers-configuration",
      "source": "./skills/security-headers-configuration",
      "description": "Configures HTTP security headers to protect against XSS, clickjacking, and MIME sniffing attacks. Use when hardening web applications, passing security audits, or implementing Content Security Policy. ",
      "keywords": ["security-headers-configuration","security","headers","configuration","vulnerability","protection","csrf","xss","http","mime"],
      "category": "security"
    }
,
    {
      "name": "seo-keyword-cluster-builder",
      "source": "./skills/seo-keyword-cluster-builder",
      "description": "Groups related keywords into topic clusters and creates content hub architecture recommendations with internal linking strategies. Use when planning content strategy, organizing keyword research, or building pillar page structures. ",
      "keywords": ["seo-keyword-cluster-builder","seo","keyword","cluster","builder","search","keywords","optimization","ranking"],
      "category": "seo"
    }
,
    {
      "name": "seo-optimizer",
      "source": "./skills/seo-optimizer",
      "description": "Analyzes and optimizes content for search engines through keyword analysis, readability assessment, technical SEO validation, and content quality evaluation. Use when improving search rankings, optimizing blog posts, or conducting content audits. ",
      "keywords": ["seo-optimizer","seo","optimizer","search","keywords","optimization","ranking","validation"],
      "category": "seo"
    }
,
    {
      "name": "sequential-thinking",
      "source": "./skills/sequential-thinking",
      "description": "Use when complex problems require systematic step-by-step reasoning with ability to revise thoughts, branch into alternative approaches, or dynamically adjust scope. Ideal for multi-stage analysis, design planning, problem decomposition, or tasks with initially unclear scope. ",
      "keywords": ["sequential-thinking","sequential","thinking","development","tooling","workflow"],
      "category": "tooling"
    }
,
    {
      "name": "session-management",
      "source": "./skills/session-management",
      "description": "Implements secure session management with JWT tokens, Redis storage, refresh flows, and proper cookie configuration. Use when building authentication systems, managing user sessions, or implementing secure logout functionality. ",
      "keywords": ["session-management","session","management","web","performance","optimization","pwa","jwt","authentication","configuration"],
      "category": "web"
    }
,
    {
      "name": "shadcn-vue",
      "source": "./skills/shadcn-vue",
      "description": "Production-ready setup for shadcn-vue, the Vue/Nuxt adaptation of shadcn/ui with Reka UI headless components and Tailwind CSS. Use when: initializing Vue or Nuxt projects with shadcn-vue, setting up accessible UI components, implementing forms with Auto Form, building data tables with TanStack Table, adding charts with Unovis, implementing dark mode, debugging component imports, or working with Reka UI components. Covers: CLI setup with bunx shadcn-vue@latest, components.json configuration, Reka UI v2 integration, 50+ component library, Auto Form with Zod schemas, Data Tables with TanStack integration, Charts with Unovis, dark mode with useColorMode, CSS variables vs utility classes, TypeScript path aliases, monorepo support, component dependencies, and migration from Radix Vue. Keywords: shadcn-vue, shadcn vue, Reka UI, radix-vue, Vue components, Nuxt components, Tailwind CSS, accessible components, headless ui, Auto Form, Zod validation, TanStack Table, data tables, Unovis charts, dark mode, useColorMode, components.json, bunx shadcn-vue, vueuse, composables, Vue 3, Nuxt 3, TypeScript, accessibility, ARIA, component library, UI components, form builder, schema validation ",
      "keywords": ["shadcn-vue","shadcn","vue","frontend","components","react","typescript","aria","cli","css","tanstack","production","validation","integration","configuration","migration"],
      "category": "frontend"
    }
,
    {
      "name": "skill-review",
      "source": "./skills/skill-review",
      "description": "Production-ready comprehensive audit skill for claude-skills repository. Use when reviewing skills for updates, investigating documented issues, verifying before marketplace submission, or checking package version currency. Performs systematic 15-phase audit covering standards compliance, dependency verification, API validation, cross-file consistency, and progressive disclosure review. Enforces official Anthropic standards including YAML validation (1,024-char descriptions, 64-char names), SKILL.md line limits (<500), and third-person style. Auto-fixes straightforward issues; asks user only for architectural decisions. Outputs severity-classified results (🔴 Critical / 🟡 High / 🟠 Medium / 🟢 Low) with evidence citations and remediation plans. See references/audit-methodology.md for complete methodology. ",
      "keywords": ["skill-review","skill","review","development","tooling","workflow","api","yaml","production","validation"],
      "category": "tooling"
    }
,
    {
      "name": "sql-query-optimization",
      "source": "./skills/sql-query-optimization",
      "description": "Comprehensive SQL query performance optimization for PostgreSQL and MySQL using indexing strategies, query plan analysis, and systematic optimization workflows. This skill provides patterns for debugging slow queries, creating optimal indexes, rewriting inefficient queries, and monitoring database performance. Use when: debugging slow database queries, analyzing EXPLAIN output, optimizing query execution plans, creating indexes for performance, rewriting N+1 queries, implementing pagination, using prepared statements, monitoring query performance, or encountering \"sequential scan\", \"missing index\", \"N+1 query problem\", \"slow LIKE queries\", \"OFFSET pagination\", \"temp table spills\", or cache hit ratio issues. Prevents 12 documented issues: sequential scans on large tables, missing indexes on foreign keys, N+1 query problems from ORMs, leading wildcard LIKE queries, SELECT * in production, missing LIMIT on large results, inefficient subqueries vs JOINs, stale statistics after bulk loads, missing composite indexes, wrong index column order, SQL injection from non-parameterized queries, and missing connection pooling. Keywords: sql optimization, query performance, database indexes, explain analyze, slow queries, n+1 problem, query plan, index strategy, composite index, covering index, postgresql performance, mysql optimization, query rewriting, prepared statements, connection pooling, sequential scan, missing index, SELECT *, LIMIT optimization, subquery performance, pagination, cursor based pagination, batch operations, pg_stat_statements, full-text search, bitmap scan, index only scan, query tuning, database performance, cache hit ratio, work_mem, shared_buffers, database monitoring ",
      "keywords": ["sql-query-optimization","sql","query","optimization","data","analytics","processing","queries","explain","like","limit","offset","select","mysql","postgresql","production"],
      "category": "data"
    }
,
    {
      "name": "sveltia-cms",
      "source": "./skills/sveltia-cms",
      "description": "Complete Sveltia CMS skill for lightweight, Git-backed content management. Sveltia is the modern successor to Decap/Netlify CMS with 5x smaller bundle (300 KB), faster GraphQL-based performance, and solves 260+ predecessor issues. Use this skill when setting up Git-based CMS for static sites (Hugo, Jekyll, 11ty, Gatsby, Astro, SvelteKit, Next.js), blogs, documentation sites, marketing sites, or migrating from Decap/Netlify CMS. Framework-agnostic with first-class i18n support and mobile-friendly editing interface. Prevents 8+ common errors including OAuth authentication failures, TOML formatting issues, YAML parse errors, CORS/COOP policy problems, content not listing, script loading errors, image upload failures, and deployment problems. Includes complete Keywords: Sveltia CMS, Git-backed CMS, Decap CMS alternative, Netlify CMS alternative, headless CMS, static site CMS, Hugo CMS, Jekyll CMS, 11ty CMS, Gatsby CMS, Astro CMS, SvelteKit CMS, Next.js CMS, content management, visual editing, markdown CMS, YAML frontmatter, i18n CMS, multilingual CMS, mobile-friendly CMS, OAuth authentication CMS, TOML config, admin/config.yml, GraphQL performance, cloudflare workers oauth proxy, OAuth authentication failure, YAML parse error, CORS COOP policy, content not listing, image upload failures Cloudflare Workers OAuth proxy setup guide. ",
      "keywords": ["sveltia-cms","sveltia","cms","content","management","publishing","coop","cors","toml","yaml","graphql","sveltekit","authentication","deployment"],
      "category": "cms"
    }
,
    {
      "name": "swift-best-practices",
      "source": "./skills/swift-best-practices",
      "description": "This skill should be used when writing or reviewing Swift code for iOS or macOS projects. Apply modern Swift 6+ best practices, concurrency patterns, API design guidelines, and migration strategies. Covers async/await, actors, MainActor, Sendable, typed throws, and Swift 6 breaking changes. ",
      "keywords": ["swift-best-practices","swift","best","practices","mobile","ios","android","app","native","api","mainactor","migration","async"],
      "category": "mobile"
    }
,
    {
      "name": "swift-settingskit",
      "source": "./skills/swift-settingskit",
      "description": "This skill provides comprehensive knowledge for building settings interfaces in SwiftUI using SettingsKit, a declarative framework for iOS, macOS, watchOS, tvOS, and visionOS apps. It should be used when creating settings screens, implementing searchable preferences, building nested navigation hierarchies, or encountering issues with settings UI state management. Use when: Building settings/preferences screens, implementing search in settings, creating nested settings navigation, customizing settings appearance, working with @Observable/@Bindable state in settings, encountering \"settings not updating\" errors, dealing with navigation state issues in settings, or migrating from traditional settings implementations. Keywords: SettingsKit, SwiftUI settings, settings interface, preferences UI, searchable settings, settings navigation, SettingsContainer, SettingsGroup, SettingsItem, CustomSettingsGroup, settings tags, settings search, Observable settings, Bindable settings, iOS 17, macOS 14, Swift 6, settings style, sidebar settings, declarative settings, settings hierarchy ",
      "keywords": ["swift-settingskit","swift","settingskit","mobile","ios","android","app","native","customsettingsgroup","settingscontainer","settingsgroup","settingsitem","swiftui","implementation"],
      "category": "mobile"
    }
,
    {
      "name": "systematic-debugging",
      "source": "./skills/systematic-debugging",
      "description": "Four-phase debugging framework that ensures root cause investigation before attempting fixes. Never jump to solutions. Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes. ",
      "keywords": ["systematic-debugging","systematic","debugging","development","tooling","workflow"],
      "category": "tooling"
    }
,
    {
      "name": "tailwind-v4-shadcn",
      "source": "./skills/tailwind-v4-shadcn",
      "description": "Production-tested setup for Tailwind CSS v4 with shadcn/ui, Vite, and React. Use when: initializing React projects with Tailwind v4, setting up shadcn/ui, implementing dark mode, debugging CSS variable issues, fixing theme switching, migrating from Tailwind v3, or encountering color/theming problems. Covers: @theme inline pattern, CSS variable architecture, dark mode with ThemeProvider, component composition, vite.config setup, common v4 gotchas, and production-tested patterns. Keywords: Tailwind v4, shadcn/ui, @tailwindcss/vite, @theme inline, dark mode, CSS variables, hsl() wrapper, components.json, React theming, theme switching, colors not working, variables broken, theme not applying, @plugin directive, typography plugin, forms plugin, prose class, @tailwindcss/typography, @tailwindcss/forms ",
      "keywords": ["tailwind-v4-shadcn","tailwind","shadcn","frontend","components","react","typescript","css","themeprovider","production"],
      "category": "frontend"
    }
,
    {
      "name": "tanstack-ai",
      "source": "./skills/tanstack-ai",
      "description": "This skill provides production-ready guidance for TanStack AI (alpha) to build provider-agnostic, type-safe AI chat with streaming, server/client tools, approval flows, and adapters for OpenAI, Anthropic, Gemini, and Ollama. Use it to scaffold new chat APIs, wire React or Solid frontends with `useChat`/`ChatClient`, define isomorphic tools with `toolDefinition().server()` / `.client()`, or debug streaming and agent loop behavior. Use when: connecting TanStack AI to OpenAI/Anthropic/Gemini/Ollama adapters, enabling SSE streaming with `toStreamResponse` + `fetchServerSentEvents`, adding tool approval (`needsApproval`) for destructive actions, implementing agent loop strategies, supporting multimodal inputs, or troubleshooting missing tool definitions and model-specific option typing. Keywords: TanStack AI, @tanstack/ai, @tanstack/ai-react, @tanstack/ai-client, @tanstack/ai-solid, @tanstack/ai-openai, @tanstack/ai-anthropic, @tanstack/ai-gemini, @tanstack/ai-ollama, toolDefinition, client tools, server tools, tool approval, agent loop, streaming, SSE, connection adapters, multimodal, type-safe models, TanStack Start, Next.js API, toStreamResponse, fetchServerSentEvents, chat, useChat, ChatClient, needsApproval ",
      "keywords": ["tanstack-ai","tanstack","machine-learning","llm","artificial-intelligence","api","sse","chatclient","openai","production","streaming"],
      "category": "ai"
    }
,
    {
      "name": "tanstack-query",
      "source": "./skills/tanstack-query",
      "description": "This skill provides comprehensive knowledge for TanStack Query v5 (React Query) server state management in React applications. It should be used when setting up data fetching with useQuery, implementing mutations with useMutation, configuring QueryClient, managing caching strategies, migrating from v4 to v5, implementing optimistic updates, using infinite queries, or encountering query/mutation errors. Use when: initializing TanStack Query in React projects, configuring QueryClient settings, creating custom query hooks, implementing mutations with error handling, setting up optimistic updates, using useInfiniteQuery for pagination, migrating from React Query v4 to v5, debugging stale data issues, fixing caching problems, resolving v5 breaking changes, implementing suspense queries, or setting up query devtools. Keywords: TanStack Query, React Query, useQuery, useMutation, useInfiniteQuery, useSuspenseQuery, QueryClient, QueryClientProvider, data fetching, server state, caching, staleTime, gcTime, query invalidation, prefetching, optimistic updates, mutations, query keys, query functions, error boundaries, suspense, React Query DevTools, v5 migration, v4 to v5, request waterfalls, background refetching, cacheTime renamed, loading status renamed, pending status, initialPageParam required, keepPreviousData removed, placeholderData, query callbacks removed, onSuccess removed, onError removed, object syntax required ",
      "keywords": ["tanstack-query","tanstack","query","frontend","components","react","typescript","devtools","queryclient","queryclientprovider","migration","caching"],
      "category": "frontend"
    }
,
    {
      "name": "tanstack-router",
      "source": "./skills/tanstack-router",
      "description": "Build type-safe, file-based routing for React applications with TanStack Router. This skill provides patterns for client-side routing, data loading, and Cloudflare Workers integration. Use when: building SPAs with type-safe navigation, implementing file-based routing, integrating with TanStack Query for data fetching, or deploying to Cloudflare Workers. Includes 7+ documented error solutions and prevents common issues: devtools dependency errors, type safety problems, loader configuration mistakes, and Vite bundling issues. ",
      "keywords": ["tanstack-router","tanstack","router","frontend","components","react","typescript","integration","configuration"],
      "category": "frontend"
    }
,
    {
      "name": "tanstack-start",
      "source": "./skills/tanstack-start",
      "description": "Full-stack React framework (Release Candidate) built on TanStack Router with server functions, selective SSR, static prerendering, and Cloudflare Workers support. Use when: migrating from Next.js, building edge-rendered React apps, needing type-safe server functions + server routes, or mixing SSR/SPA per route. Includes Cloudflare deployment recipes, hydration troubleshooting, and auth/data patterns. ",
      "keywords": ["tanstack-start","tanstack","start","frontend","components","react","typescript","spa","ssr","deployment","edge"],
      "category": "frontend"
    }
,
    {
      "name": "tanstack-table",
      "source": "./skills/tanstack-table",
      "description": "Build production-ready data tables with headless TanStack Table v8. This skill provides server-side pagination, filtering, and sorting patterns optimized for Cloudflare Workers + D1 databases. Use when: building data tables with large datasets, implementing server-side table features, integrating with TanStack Query for data fetching, or need virtualization for performance. Includes 6+ documented error solutions and Cloudflare D1 integration examples. Prevents common issues: server-side state management confusion, TanStack Query coordination errors, manual sorting setup mistakes, URL state sync problems, and performance issues with large datasets. ",
      "keywords": ["tanstack-table","tanstack","table","frontend","components","react","typescript","url","production","integration"],
      "category": "frontend"
    }
,
    {
      "name": "technical-specification",
      "source": "./skills/technical-specification",
      "description": "Creates detailed technical specifications for software projects covering requirements, architecture, APIs, and testing strategies. Use when planning features, documenting system design, or creating architecture decision records. ",
      "keywords": ["technical-specification","technical","specification","documentation","docs","technical-writing","specs"],
      "category": "documentation"
    }
,
    {
      "name": "test-quality-analysis",
      "source": "./skills/test-quality-analysis",
      "description": "Detect test smells, overmocking, flaky tests, and coverage issues. Analyze test effectiveness, maintainability, and reliability. Use when reviewing tests or improving test quality. ",
      "keywords": ["test-quality-analysis","test","quality","analysis","testing","tests","unit-tests","integration"],
      "category": "testing"
    }
,
    {
      "name": "thesys-generative-ui",
      "source": "./skills/thesys-generative-ui",
      "description": "AI-powered generative UI with Thesys - create React components from natural language. ",
      "keywords": ["thesys-generative-ui","thesys","generative","machine-learning","llm","artificial-intelligence"],
      "category": "ai"
    }
,
    {
      "name": "turborepo",
      "source": "./skills/turborepo",
      "description": "Guide for implementing Turborepo - a high-performance build system for JavaScript and TypeScript monorepos. Use when setting up monorepos, optimizing build performance, implementing task pipelines, configuring caching strategies, or orchestrating tasks across multiple packages. ",
      "keywords": ["turborepo","development","tooling","workflow","javascript","typescript","caching"],
      "category": "tooling"
    }
,
    {
      "name": "typescript-mcp",
      "source": "./skills/typescript-mcp",
      "description": "Use this skill when building MCP (Model Context Protocol) servers with TypeScript on Cloudflare Workers. This skill provides production-tested patterns for implementing tools, resources, and prompts using the official @modelcontextprotocol/sdk. It prevents 10+ common errors including export syntax issues, schema validation failures, memory leaks from unclosed transports, CORS misconfigurations, and authentication vulnerabilities. This skill should be used when developers need stateless MCP servers for API integrations, external tool exposure, or serverless edge deployments. For stateful agents with WebSockets and persistent storage, consider the Cloudflare Agents SDK instead. Supports multiple authentication methods (API keys, OAuth, Zero Trust), Cloudflare service integrations (D1, KV, R2, Vectorize), and comprehensive testing strategies. Production tested with token savings of ~70% vs manual implementation. Keywords: mcp, model context protocol, typescript mcp, cloudflare workers mcp, mcp server, mcp tools, mcp resources, mcp sdk, @modelcontextprotocol/sdk, hono mcp, streamablehttpservertransport, mcp authentication, mcp cloudflare, edge mcp server, serverless mcp, typescript mcp server, mcp api, llm tools, ai tools, cloudflare d1 mcp, cloudflare kv mcp, mcp testing, mcp deployment, wrangler mcp, export syntax error, schema validation error, memory leak mcp, cors mcp, rate limiting mcp ",
      "keywords": ["typescript-mcp","typescript","mcp","development","tooling","workflow","api","cors","sdk","websockets","production","authentication","validation","integration","implementation","deployment","serverless","edge"],
      "category": "tooling"
    }
,
    {
      "name": "ultracite",
      "source": "./skills/ultracite",
      "description": "Use when setting up, configuring, or migrating to Ultracite, a fast Rust-based linting and formatting tool built on Biome. This skill provides comprehensive guidance for project setup, framework-specific configurations (React, Next.js, Vue, Svelte), Git hook integrations (Husky, Lefthook, lint-staged), AI editor rules, monorepo support, and migrations from ESLint, Prettier, or Biome. Includes project suitability assessment, troubleshooting, known limitations, and best practices for JavaScript/TypeScript projects. ",
      "keywords": ["ultracite","frontend","components","react","typescript","javascript","integration","configuration","migration"],
      "category": "frontend"
    }
,
    {
      "name": "vercel-blob",
      "source": "./skills/vercel-blob",
      "description": "This skill provides comprehensive knowledge for integrating Vercel Blob object storage into Vercel applications. It should be used when setting up file uploads, managing images and documents, implementing CDN-delivered assets, or handling large files in Next.js serverless and edge functions. Use this skill when: - Setting up file uploads for Next.js applications (images, PDFs, videos) - Implementing client-side uploads with presigned URLs - Managing user-generated content (avatars, attachments, media) - Building file management features (list, download, delete) - Migrating from Cloudflare R2 to Vercel Blob - Encountering errors like \"BLOB_READ_WRITE_TOKEN not set\", \"file size limit exceeded\", or \"client upload token errors\" - Need simple object storage with automatic CDN distribution Keywords: vercel blob, @vercel/blob, vercel storage, vercel file upload, vercel cdn, blob storage vercel, client upload vercel, presigned url vercel, file upload nextjs, image upload vercel, pdf upload, video upload, user uploads, multipart upload, streaming upload, blob cdn, vercel assets, file download ",
      "keywords": ["vercel-blob","vercel","blob","database","orm","sql","storage","query","cdn","serverless","edge","streaming"],
      "category": "database"
    }
,
    {
      "name": "vercel-kv",
      "source": "./skills/vercel-kv",
      "description": "This skill provides comprehensive knowledge for integrating Vercel KV (Redis-compatible key-value storage powered by Upstash) into Vercel applications. It should be used when setting up Vercel KV for Next.js applications, implementing caching patterns, managing sessions, or handling rate limiting in edge and serverless functions. Use this skill when: - Setting up Vercel KV for Next.js applications - Implementing caching strategies (page cache, API cache, data cache) - Managing user sessions or authentication tokens in serverless environments - Building rate limiting for APIs or features - Storing temporary data with TTL (time-to-live) - Migrating from Cloudflare KV to Vercel KV - Encountering errors like \"KV_REST_API_URL not set\", \"rate limit exceeded\", or \"JSON serialization errors\" - Need Redis-compatible API with strong consistency (vs eventual consistency) Keywords: vercel kv, @vercel/kv, vercel redis, upstash vercel, kv vercel, redis vercel edge, key-value vercel, vercel cache, vercel sessions, vercel rate limit, redis upstash, kv storage, edge kv, serverless redis, vercel ttl, vercel expire, kv typescript, next.js kv, server actions kv, edge runtime kv ",
      "keywords": ["vercel-kv","vercel","database","orm","sql","storage","query","api","json","ttl","authentication","serverless","edge","caching"],
      "category": "database"
    }
,
    {
      "name": "verification-before-completion",
      "source": "./skills/verification-before-completion",
      "description": "Run verification commands and confirm output before claiming success. Use when about to claim work is complete, fixed, or passing, before committing or creating PRs. ",
      "keywords": ["verification-before-completion","verification","before","completion","development","tooling","workflow"],
      "category": "tooling"
    }
,
    {
      "name": "vitest-testing",
      "source": "./skills/vitest-testing",
      "description": "Modern TypeScript/JavaScript testing with Vitest. Fast unit and integration tests, native ESM support, Vite-powered HMR, and comprehensive mocking. Use for testing TS/JS projects. ",
      "keywords": ["vitest-testing","vitest","testing","tests","unit-tests","integration","quality","esm","hmr","javascript","typescript"],
      "category": "testing"
    }
,
    {
      "name": "vulnerability-scanning",
      "source": "./skills/vulnerability-scanning",
      "description": "Implements automated security scanning for dependencies, code, and containers using tools like Trivy, Snyk, and npm audit. Use when setting up CI/CD security gates, conducting pre-deployment audits, or meeting compliance requirements. ",
      "keywords": ["vulnerability-scanning","vulnerability","scanning","security","protection","csrf","xss","deployment"],
      "category": "security"
    }
,
    {
      "name": "web-performance-audit",
      "source": "./skills/web-performance-audit",
      "description": "Conducts comprehensive web performance audits measuring Core Web Vitals, identifying bottlenecks, and implementing optimizations. Use when improving page load times, preparing for performance reviews, or optimizing user experience. ",
      "keywords": ["web-performance-audit","web","performance","audit","optimization","pwa"],
      "category": "web"
    }
,
    {
      "name": "web-performance-optimization",
      "source": "./skills/web-performance-optimization",
      "description": "Optimizes web application performance through code splitting, lazy loading, caching strategies, and Core Web Vitals monitoring. Use when improving page load times, implementing service workers, or reducing bundle sizes. ",
      "keywords": ["web-performance-optimization","web","performance","optimization","pwa","caching"],
      "category": "web"
    }
,
    {
      "name": "websocket-implementation",
      "source": "./skills/websocket-implementation",
      "description": "Implements real-time WebSocket communication with connection management, room-based messaging, and horizontal scaling. Use when building chat systems, live notifications, collaborative tools, or real-time dashboards. ",
      "keywords": ["websocket-implementation","websocket","implementation","api","rest","graphql","endpoints","http","real-time"],
      "category": "api"
    }
,
    {
      "name": "woocommerce-backend-dev",
      "source": "./skills/woocommerce-backend-dev",
      "description": "Add or modify WooCommerce backend PHP code following project conventions. Use when creating new classes, methods, hooks, or modifying existing backend code in WooCommerce projects. ",
      "keywords": ["woocommerce-backend-dev","woocommerce","backend","dev","wordpress","ecommerce","shop","php"],
      "category": "woocommerce"
    }
,
    {
      "name": "woocommerce-code-review",
      "source": "./skills/woocommerce-code-review",
      "description": "Review WooCommerce code changes for coding standards compliance. Use when reviewing code locally, performing automated PR reviews, or checking code quality in WooCommerce projects. ",
      "keywords": ["woocommerce-code-review","woocommerce","code","review","wordpress","ecommerce","shop"],
      "category": "woocommerce"
    }
,
    {
      "name": "woocommerce-copy-guidelines",
      "source": "./skills/woocommerce-copy-guidelines",
      "description": "Guidelines for UI text and copy in WooCommerce. Use when writing user-facing text, labels, buttons, messages, or documentation in WooCommerce projects. ",
      "keywords": ["woocommerce-copy-guidelines","woocommerce","copy","guidelines","wordpress","ecommerce","shop"],
      "category": "woocommerce"
    }
,
    {
      "name": "woocommerce-dev-cycle",
      "source": "./skills/woocommerce-dev-cycle",
      "description": "Run tests, linting, and quality checks for WooCommerce development. Use when running tests, fixing code style, or following the development workflow in WooCommerce projects. ",
      "keywords": ["woocommerce-dev-cycle","woocommerce","dev","cycle","wordpress","ecommerce","shop"],
      "category": "woocommerce"
    }
,
    {
      "name": "wordpress-plugin-core",
      "source": "./skills/wordpress-plugin-core",
      "description": "This skill provides comprehensive knowledge for WordPress plugin development, covering core patterns, security best practices, database interactions, hooks/filters, Settings API, custom post types, REST API, and AJAX. This skill should be used when creating WordPress plugins, troubleshooting security issues, implementing custom post types/taxonomies, building admin interfaces, or working with the WordPress database. Use when: Creating new WordPress plugins, implementing nonces/sanitization/escaping, working with $wpdb and prepared statements, building Settings API pages, registering custom post types or taxonomies, implementing REST API endpoints, handling AJAX requests, debugging plugin activation/deactivation issues, preventing SQL injection/XSS/CSRF vulnerabilities. Keywords: wordpress plugin development, wordpress security, wordpress hooks, wordpress filters, wordpress database, wpdb prepare, sanitize_text_field, esc_html, wp_nonce, custom post type, register_post_type, settings api, rest api, admin-ajax, wordpress sql injection, wordpress xss, wordpress csrf, plugin header, activation hook, deactivation hook, wordpress coding standards, wordpress plugin architecture ",
      "keywords": ["wordpress-plugin-core","wordpress","plugin","core","cms","content","management","publishing","ajax","api","csrf","rest","sql","xss"],
      "category": "cms"
    }
,
    {
      "name": "xss-prevention",
      "source": "./skills/xss-prevention",
      "description": "Prevents Cross-Site Scripting attacks through input sanitization, output encoding, and Content Security Policy. Use when handling user-generated content, implementing rich text editors, or securing web applications. ",
      "keywords": ["xss-prevention","xss","prevention","security","vulnerability","protection","csrf"],
      "category": "security"
    }
,
    {
      "name": "zod",
      "source": "./skills/zod",
      "description": "TypeScript-first schema validation and type inference library. Use when: validating API requests/responses, form data, environment variables, or configuration; defining type-safe data schemas with runtime validation; transforming and refining data with custom logic; generating JSON Schema for OpenAPI or AI structured outputs; ensuring data integrity with zero dependencies (2kb gzipped); working with tRPC, React Hook Form, Prisma, or other ecosystem integrations. Prevents errors: missing validation leading to runtime crashes, incorrect type inference, unhandled validation errors, improper error message formatting, using outdated patterns, inefficient schema composition, missing refinements for business logic, incorrect async validation setup. ",
      "keywords": ["zod","development","tooling","workflow","api","json","openapi","typescript","validation","integration","configuration","async"],
      "category": "tooling"
    }
,
    {
      "name": "zustand-state-management",
      "source": "./skills/zustand-state-management",
      "description": "Production-tested setup for Zustand state management in React applications with TypeScript. This skill provides comprehensive patterns for building scalable, type-safe global state. Use when: setting up global state in React, migrating from Redux or Context API, implementing state persistence with localStorage, configuring TypeScript with Zustand, using slices pattern for modular stores, adding devtools middleware for debugging, handling Next.js SSR hydration, or encountering hydration errors, TypeScript inference issues, or persist middleware problems. Prevents 5 documented issues: Next.js hydration mismatches, TypeScript double parentheses syntax errors, persist middleware export errors, infinite render loops, and slices pattern type inference failures. Keywords: zustand, state management, React state, TypeScript state, persist middleware, devtools, slices pattern, global state, React hooks, create store, useBoundStore, StateCreator, hydration error, text content mismatch, infinite render, localStorage, sessionStorage, immer middleware, shallow equality, selector pattern, zustand v5 ",
      "keywords": ["zustand-state-management","zustand","state","management","frontend","components","react","typescript","api","ssr","statecreator","scalable","production"],
      "category": "frontend"
    }
  ]
}
